{
  "agent_execution_id": 1,
  "project": "code4rena_loopfi_2025_02",
  "status": "Status.SUCCESS",
  "result": {
    "project": "code4rena_loopfi_2025_02",
    "timestamp": "2026-02-03T20:50:29.421614",
    "total_expected": 2,
    "total_found": 0,
    "true_positives": 0,
    "false_negatives": 2,
    "false_positives": 0,
    "detection_rate": 0.0,
    "result": "FAIL",
    "precision": 0.0,
    "f1_score": 0.0,
    "matched_findings": [],
    "missed_findings": [
      {
        "id": "code4rena_loopfi_2025_02_expected_000",
        "title": "Rewards might be lost due to the error that_updateRewardIndex()might advancelastBalancewithout advancing index for a token",
        "description": "Submitted by\nchaduke\n, also found by\nEvo\n\nThe function\n_updateRewardIndex()\nis used to update the\nlastBalance\nand\nindex\nof each reward token. This function will be called when a user deposits, withdraws collateral or claims rewards.\n\nHowever, the function might not advance\nindex\nwhen\naccrued.divDown(totalShares) = 0\n. This might happen when\ntotalShares\nis too big and\naccrued\nis too small. One case is that the number of decimals for the reward token is too small.\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L74\n\nFor example, the USDC token only has 6 decimals.\n\nSuppose\naccrued\n=\n$100 = 100*10**6\n, and\ntotalShares\n= 200M = 200 * 10** 6 * 10**18\n; then we have\naccrued.divDown(totalShares) = 0\n.\n\nFurthermore, if function\n_updateRewardIndex()\nis called more frequently, either because a malicious user keeps calling\ngetRewards()\n(the gas fee is low on Arbitrum) or simply because the community is large so there is a high chance that for each block (per 12 seconds on Ethereum), there is someone who calls a\nwithdraw\n/\ndeposit\n/\ngetRewards\nfunction. As a result,\naccrued\ncould be small, leading to\naccrued.divDown(totalShares) = 0\n. Meanwhile,\n_updateRewardIndex()\nalways advances\nlastBalance\nwhen\naccrued !=0\n:\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L78\n\nThis means the accrued rewards are lost! Nobody will receive the rewards since index has not changed.\n\nMore importantly, due to the rounding down error for\naccrued.divDown(totalShares)\n, there is always a slight loss for the rewards, which is accumulative over time.\n\nThe fix is simple. Calculate\ndeltaIndex = accrued.divDown(totalShares)\nand advance\nlastBalance\nby\ndeltaIndex.mulDown(totalShares)\n. In this way,\nindex\nand\nlastBalance\nwill always advance in the same pace; in particular if index does not advance, then\nlastBalance\nwill not advance either. The rounding down error is eliminated too since the\nlastBalance\nwill not be\naccrued\nbut by\ndeltaIndex.mulDown(totalShares)\n.\n\nMath\n\n0xtj24 (LoopFi) confirmed\n\n0xAlix2 (warden) commented\n:\n\n@Koolex - I agree that this is an issue; however, the audit\ndocs\nstates that the ERC20s that are used by the protocol are WETH and PendleLPs which are both 18 decimals.\nERC20 used by the protocol | WETH, PendleLPs\nBut I\u2019m not sure if that should be considered valid in this context.\n\nKoolex (judge) commented\n:\n\nThere is another issue here.\nmalicious user keeps calling\ngetRewards()",
        "severity": "high",
        "reason": "No unmatched tool findings remaining"
      },
      {
        "id": "code4rena_loopfi_2025_02_expected_001",
        "title": "CDPVault.sol#liquidatePositionBadDebt()doesn\u2019t correctly handle profit and loss",
        "description": "Submitted by\npkqs90\n, also found by\n0xAlix2\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/CDPVault.sol#L702\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/PoolV3.sol#L593\n\nWhen liquidating bad debt, the profit and loss is not correctly handled. This will cause incorrect accounting to lpETH stakers.\n\nNote: This is based on the 2024-07 Loopfi audit\nH-12\nissue. This protocol team applied a fix, but the fix is incomplete.\n\nThere are two issues that needs to be fixed in the new codebase:\n\nThe\nprofit\nthat is passed in\npool.repayCreditAccount(debtData.debt, profit, loss);\nshould actually use\ndebtData.accruedInterest\n. This is because we should first \u201cassume\u201d full debt and interest is paid off, and calculate the loss part independently.\nThe\nloss\nis correctly calculated in\nPoolV3#repayCreditAccount\n, but the if-else branch is incorrectly implemented. Currently, it can\u2019t handle the case where both profit and loss is non-zero. This would cause a issue that the loss will not be accounted, and will ultimately cause loss to lpETH holders (loss will be implicitly added to the users who hold lpETH) instead of lpETH stakers.\n\nThe second fix was also suggested in the original issue, but it isn\u2019t applied.\n\nCDPVault.sol:\n\ntakeCollateral\n=\nposition\n.\ncollateral\n;\nrepayAmount\n=\nwmul\n(\ntakeCollateral\n,\ndiscountedPrice\n);\nuint256\nloss\n=\ncalcTotalDebt\n(\ndebtData\n) -\nrepayAmount\n;\nuint256\nprofit\n;\nif\n(\nrepayAmount\n>\ndebtData\n.\ndebt\n) {\n@>\nprofit\n=\nrepayAmount\n-\ndebtData\n.\ndebt\n;\n}\n...\n@>\npool\n.\nrepayCreditAccount\n(\ndebtData\n.\ndebt\n,\nprofit\n,\nloss\n);\n// U:[CM-11]\n// transfer the collateral amount from the vault to the liquidator\ntoken\n.\nsafeTransfer\n(\nmsg\n.\nsender\n,\ntakeCollateral\n);\n\nPoolV3.sol:\n\nfunction\nrepayCreditAccount\n(\nuint256\nrepaidAmount\n,\nuint256\nprofit\n,\nuint256\nloss\n)\nexternal\noverride\ncreditManagerOnly\n// U:[LP-2C]\nwhenNotPaused\n// U:[LP-2A]\nnonReentrant\n// U:[LP-2B]\n{\n...\nif\n(\nprofit\n>\n0\n) {\n_mint\n(\ntreasury\n,\n_convertToShares\n(\nprofit\n));\n// U:[LP-14B]\n@>      }\nelse\nif\n(\nloss\n>\n0\n) {\naddress\ntreasury_\n=\ntreasury\n;\nuint256\nsharesInTreasury\n=\nbalanceOf\n(\ntreasury_\n);\nuint256\nsharesToBurn\n=\n_convertToShares\n(\nloss\n);\nif\n(\nsharesToBurn\n>\nsharesInTreasury\n) {\nunchecked\n{\nemit\nIncurUncoveredLoss\n({\ncreditManager:\nmsg\n.\nsender\n,\nloss:\n_convertToAssets\n(\nsharesToBurn\n-\nsharesInTreasury\n)\n});\n// U:[LP-14D]\n}\nsharesToBurn\n=\nsharesInTreasury\n;\n}\n_burn\n(\ntreasury_\n,\nsharesToBurn\n);\n// U:[LP-14C,14D]\n}\n...\n}\n\nIn CDPVault, change to\npool.repayCreditAccount(debtData.debt, debtData.accruedInterest, loss)\n.\n\nIn PoolV3:\n\nif\n(\nprofit\n>\n0\n) {\n_mint\n(\ntreasury\n,\nconvertToShares\n(\nprofit\n));\n// U:[LP-14B]\n+       }\n+\nif\n(\nloss\n>\n0\n)\n-       }\nelse\nif\n(\nloss\n>\n0\n) {\n...\n}\n\n0xtj24 (LoopFi) confirmed\n\nKoolex (judge) commented\n:\n\nWhy Profit should be\ndebtData.accruedInterest\n?\nFor the second part, could you please provide a case where profit and loss are non-zero in PJQA?\n\npkqs90 (warden) commented\n:\n\n@Koolex - Here\u2019s an example scenario:\nUser originally taken out a debt of 100, and interest grows to 50, so\ndebtData.debt = 100, debtData.accruedInterest = 50, calcTotalDebt(debtData) = 150)\n.\nUser collateral is only 100, and after multiplying\ndiscountPrice\n, the\nrepayAmount\nis only 90. Bad debt occurs.\nloss = calcTotalDebt(debtData) - repayAmount\nis equal to\n150 - 90 = 60\n.\nSince\nrepayAmount < debtData.debt\n, we would have\nprofit = 0\n.\nThis means for\nPoolV3#repayCreditAccount\n, 60 shares would be burned from the treasury, while instead it should be 10 (because original debt was 100, repaid is 90,\n100 - 90 = 10\n).\nYou can also see that if\nrepayAmount\nwas 101, we would calculate\nprofit = 1\n, and in\nPoolV3#repayCreditAccount\nwe would mint 1 share instead. This means there is a 61 (\n1 - (-60) = 61\n) gap in treasury shares when the repaid amount diff is only 11 (\n101 - 90 = 11\n), which does not make any sense.\nfunction\ncalcTotalDebt\n(\nDebtData\nmemory\ndebtData\n)\ninternal\npure\nreturns\n(\nuint256\n) {\nreturn\ndebtData\n.\ndebt\n+\ndebtData\n.\naccruedInterest\n;\n//+ debtData.accruedFees;\n}\nfunction\nliquidatePositionBadDebt\n(\naddress\nowner\n,\nuint256\nrepayAmount\n)\nexternal\nwhenNotPaused\n{\n...\ntakeCollateral\n=\nposition\n.\ncollateral\n;\nrepayAmount\n=\nwmul\n(\ntakeCollateral\n,\ndiscountedPrice\n);\n@>\nuint256\nloss\n=\ncalcTotalDebt\n(\ndebtData\n) -\nrepayAmount\n;\nuint256\nprofit\n;\nif\n(\nrepayAmount\n>\ndebtData\n.\ndebt\n) {\n@>\nprofit\n=\nrepayAmount\n-\ndebtData\n.\ndebt\n;\n}\n...\n@>\npool\n.\nrepayCreditAccount\n(\ndebtData\n.\ndebt\n,\nprofit\n,\nloss\n);\n// U:[CM-11]\n// transfer the collateral amount from the vault to the liquidator\ntoken\n.\nsafeTransfer\n(\nmsg\n.\nsender\n,\ntakeCollateral\n);\n}\nPoolV3.sol:\nfunction\nrepayCreditAccount\n(\nuint256\nrepaidAmount\n,\nuint256\nprofit\n,\nuint256\nloss\n)\nexternal\noverride\ncreditManagerOnly\n// U:[LP-2C]\nwhenNotPaused\n// U:[LP-2A]\nnonReentrant\n// U:[LP-2B]\n{\nuint128\nrepaidAmountU128\n=\nrepaidAmount\n.\ntoUint128\n();\nDebtParams\nstorage\ncmDebt\n=\n_creditManagerDebt\n[\nmsg\n.\nsender\n];\nuint128\ncmBorrowed\n=\ncmDebt\n.\nborrowed\n;\nif\n(\ncmBorrowed\n==\n0\n) {\nrevert\nCallerNotCreditManagerException\n();\n// U:[LP-2C,14A]\n}\nif\n(\nprofit\n>\n0\n) {\n_mint\n(\ntreasury\n,\n_convertToShares\n(\nprofit\n));\n// U:[LP-14B]\n}\nelse\nif\n(\nloss\n>\n0\n) {\naddress\ntreasury_\n=\ntreasury\n;\nuint256\nsharesInTreasury\n=\nbalanceOf\n(\ntreasury_\n);\nuint256\nsharesToBurn\n=\n_convertToShares\n(\nloss\n);\nif\n(\nsharesToBurn\n>\nsharesInTreasury\n) {\nunchecked\n{\nemit\nIncurUncoveredLoss\n({\ncreditManager:\nmsg\n.\nsender\n,\nloss:\n_convertToAssets\n(\nsharesToBurn\n-\nsharesInTreasury\n)\n});\n// U:[LP-14D]\n}\nsharesToBurn\n=\nsharesInTreasury\n;\n}\n_burn\n(\ntreasury_\n,\nsharesToBurn\n);\n// U:[LP-14C,14D]\n}...\n}\n\nKoolex (judge) commented\n:\n\n@pkqs90 - Could you please point out the incomplete fix? This is important, since if there is no indication that the sponsor intended to fix it, it would be out of scope (according to this\nannouncement\n).\n\npkqs90 (warden) commented\n:\n\n@Koolex - The 2024-07 code had\npool.repayCreditAccount(debtData.debt, 0, loss);\nhttps://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol#L624\n, and was later fixed to\npool.repayCreditAccount(debtData.debt, profit, loss);\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/CDPVault.sol#L702\n.\nThe suggested fix was also mentioned the original report for\nH-12\n.",
        "severity": "high",
        "reason": "No unmatched tool findings remaining"
      }
    ],
    "extra_findings": [],
    "undecided_findings": []
  }
}