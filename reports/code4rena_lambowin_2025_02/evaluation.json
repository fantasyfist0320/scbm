{
  "agent_execution_id": 1,
  "project": "code4rena_lambowin_2025_02",
  "status": "Status.SUCCESS",
  "result": {
    "project": "code4rena_lambowin_2025_02",
    "timestamp": "2026-02-03T20:49:00.570233",
    "total_expected": 4,
    "total_found": 0,
    "true_positives": 0,
    "false_negatives": 4,
    "false_positives": 0,
    "detection_rate": 0.0,
    "result": "FAIL",
    "precision": 0.0,
    "f1_score": 0.0,
    "matched_findings": [],
    "missed_findings": [
      {
        "id": "code4rena_lambowin_2025_02_expected_000",
        "title": "Loss of User Funds in VirtualToken\u2019scashInFunction Due to Incorrect Amount Minting",
        "description": "Submitted by\naldarion\n, also found by\n056Security\n,\n0xaudron\n,\n0xbrett8571\n,\n0xGondar\n,\n0xgremlincat\n,\n0xiehnnkta\n,\n0xiehnnkta\n,\n0xKann\n,\n0xLasadie\n,\n0xleadwizard\n,\n0xLeveler\n,\n0xMitev\n,\n0xMosh\n,\n4B\n,\n4rdiii\n,\nAgontuk\n,\nAkay\n,\nanonymousjoe\n,\nast3ros\n,\naster\n,\naua_oo7\n,\nBauchibred\n,\nBenRai\n,\nBenRai\n,\nBryan_Conquer\n,\nbumbleb33\n,\nc0pp3rscr3w3r\n,\nchaduke\n,\nColdless\n,\nColdless\n,\nCrazyMoose\n,\ncrmx_lom\n,\ndd0x7e8\n,\ndhank\n,\nDharkArtz\n,\ndic0de\n,\nEchoKly\n,\neLSeR17\n,\nEPSec\n,\nETHworker\n,\nEvo\n,\nFalseGenius\n,\nfarismaulana\n,\nfavelanky\n,\nFitro\n,\nFon\n,\nfranfran20\n,\ngkrastenov\n,\nGosho\n,\nharry_cryptodev\n,\nhoney-k12\n,\nhyuunn\n,\nicy_petal\n,\nInfect3d\n,\ninh3l\n,\nIzuMan\n,\njaraxxus\n,\njesusrod15\n,\nJiri123\n,\njkk812812\n,\nJohn_Femi\n,\njrstrunk\n,\njyjh\n,\nKiteWeb3\n,\nKKaminsk\n,\nkomorebi\n,\nKupiaSec\n,\nlanyi2023\n,\nLe_Rems\n,\nLe_Rems\n,\nLeFy\n,\nLordAdhaar\n,\nm4k2\n,\nm4k2\n,\nmacart224\n,\nMatin\n,\nmgf15\n,\nmontecristo\n,\nMoyinmaala\n,\nMrPotatoMagic\n,\nmrudenko\n,\nnewspacexyz\n,\nNexusAudits\n,\nOpaBatyo\n,\nOxsadeeq\n,\nparishill24\n,\npfapostol\n,\npontifex\n,\nprapandey031\n,\nProsperity\n,\nPumpkingWok\n,\nrare_one\n,\nRhaydden\n,\nrilwan99\n,\nRobinx33\n,\nrouhsamad\n,\nrspadi\n,\nsaikumar279\n,\nShubham\n,\nsilver_eth\n,\nSilverwind\n,\nslowbugmayor\n,\nSpicyMeatball\n,\nStingo\n,\nstuart_the_minion\n,\nSummer\n,\nTenderBeastJr\n,\nthreadmodeling\n,\ntpiliposian\n,\ntusharr1411\n,\nTychai0s\n,\ntypicalHuman\n,\nudo\n,\nVagabond\n,\nVasquez\n,\nviking71\n,\nvladi319\n,\nweb3km\n,\nwillycode20\n,\nX0sauce\n,\nxiao\n,\nYoanYJD\n,\nzaevlad\n,\nzaevlad\n,\nZhengZuo999\n,\nzxriptor\n, and\nzzebra83\n\nhttps://github.com/code-423n4/2024-12-lambowin/blob/874fafc7b27042c59bdd765073f5e412a3b79192/src/VirtualToken.sol#L78\n\nIn the VirtualToken contract\ncashIn()\nfunction uses msg.value instead of amount for minting tokens when dealing with ERC20 tokens. This causes users to lose their deposited ERC20 tokens as they receive 0 virtual tokens in return.\n\nThe root cause is the incorrect usage of msg.value in the minting logic. While the function correctly handles the token transfer with the amount parameter, it incorrectly uses msg.value for minting, which is probably 0 for ERC20 token transactions. They receive 0 virtual tokens in return (since msg.value is 0 for ERC20 transactions)\n\nfunction\ncashIn\n(\nuint256\namount\n)\nexternal\npayable\nonlyWhiteListed\n{\nif\n(\nunderlyingToken\n==\nLaunchPadUtils\n.\nNATIVE_TOKEN\n) {\nrequire\n(\nmsg\n.\nvalue\n==\namount\n,\n\"Invalid ETH amount\"\n);\n}\nelse\n{\n_transferAssetFromUser\n(\namount\n);\n}\n// @audit Critical: Using msg.value instead of amount\n_mint\n(\nmsg\n.\nsender\n,\nmsg\n.\nvalue\n);\n// Will be 0 for ERC20 tokens\nemit\nCashIn\n(\nmsg\n.\nsender\n,\nmsg\n.\nvalue\n);\n}\n\nfunction\ncashIn\n(\nuint256\namount\n)\nexternal\npayable\nonlyWhiteListed\n{\nif\n(\nunderlyingToken\n==\nLaunchPadUtils\n.\nNATIVE_TOKEN\n) {\nrequire\n(\nmsg\n.\nvalue\n==\namount\n,\n\"Invalid ETH amount\"\n);\n}\nelse\n{\n_transferAssetFromUser\n(\namount\n);\n}\n_mint\n(\nmsg\n.\nsender\n,\namount\n);\n// Use amount instead of msg.value\n}\n\nShaneson (Lambo.win) confirmed and commented\n:\n\nVirtualToken should support USDT, USDC in the future, so cashIn should use amount instead of msg.value. This is the\nfixed PR\n, please review.",
        "severity": "high",
        "reason": "No unmatched tool findings remaining"
      },
      {
        "id": "code4rena_lambowin_2025_02_expected_001",
        "title": "LamboFactory can be permanently DoS-ed due tocreatePaircall reversal",
        "description": "Submitted by\nzxriptor\n, also found by\nast3ros\n,\nEvo\n,\nFalseGenius\n,\nGiorgio\n,\nInfect3d\n,\ninh3l\n,\nLe_Rems\n,\nm4k2\n,\nmrudenko\n,\npaco\n,\nrouhsamad\n,\nshaflow2\n,\nSpicyMeatball\n,\nTheFabled\n,\nthreadmodeling\n, and\nweb3km\n\nhttps://github.com/code-423n4/2024-12-lambowin/blob/main/src/LamboFactory.sol#L72\n\nLamboFactory.createLaunchPad\ndeploys new token contract and immediately sets up a new Uniswap V2 pool by calling\ncreatePair\n. This can be frontrun by the attacker by setting up a pool for the next token to be deployed.\n\nContract addresses are deterministic and can be calculated in advance. That opens a possibility for the attacker to pre-calculate the address of the next LamboToken to be deployed. As can be seen below, LamboFactory uses\nclone\n() method from OpenZeppelin\nClones\nlibrary, which uses\nCREATE\nEMV opCode under the hood.\n\nfunction\n_deployLamboToken\n(\nstring\nmemory\nname\n,\nstring\nmemory\ntickname\n)\ninternal\nreturns\n(\naddress\nquoteToken\n) {\n// Create a deterministic clone of the LamboToken implementation\n>>>\nquoteToken\n=\nClones\n.\nclone\n(\nlamboTokenImplementation\n);\n// Initialize the cloned LamboToken\nLamboToken\n(\nquoteToken\n).\ninitialize\n(\nname\n,\ntickname\n);\nemit\nTokenDeployed\n(\nquoteToken\n);\n}\n\nCREATE\nopcode calculates new contract address based on factory contract address and nonce (number of deployed contracts the factory has previously deployed):\n\nThe destination address is calculated as the rightmost 20 bytes (160 bits) of the Keccak-256 hash of the rlp encoding of the sender address followed by its nonce. That is:\naddress = keccak256(rlp([sender\naddress,sender\nnonce]))[12:]\n\nhttps://www.evm.codes/#f0\n\nHence an attacker can calculate the address of the next token to be deployed and directly call\nUniswapV2Factory.createPair\nwhich will result in a new liquidity pool being created BEFORE the token has been deployed.\n\nSuch state will lead all subsequent calls to\nLamboFactory.createLaunchPad\nto revert, because of the pair existence check in Uniswap code, without the possibility to fix that:\n\nhttps://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Factory.sol#L27\n\nfunction\ncreatePair\n(\naddress\ntokenA\n,\naddress\ntokenB\n)\nexternal\nreturns\n(\naddress\npair\n) {\nrequire\n(\ntokenA\n!=\ntokenB\n,\n'UniswapV2: IDENTICAL_ADDRESSES'\n);\n(\naddress\ntoken0\n,\naddress\ntoken1\n) =\ntokenA\n<\ntokenB\n? (\ntokenA\n,\ntokenB\n) : (\ntokenB\n,\ntokenA\n);\nrequire\n(\ntoken0\n!=\naddress\n(\n0\n),\n'UniswapV2: ZERO_ADDRESS'\n);\n>>>\nrequire\n(\ngetPair\n[\ntoken0\n][\ntoken1\n] ==\naddress\n(\n0\n),\n'UniswapV2: PAIR_EXISTS'\n);\n// single check is sufficient\n// ... the rest of the code is ommitted ...\n}\n\nCheck pool existence using\nIUniswapV2Factory.getPair()\n.\n\nShaneson (Lambo.win) commented\n:\n\nWe would use cloneDeterministic instead of clone, and the backend will pass the random salt from off-chain.\nAnd this is the\nfixed PR\n.\n\nKoolex (judge) commented\n:\n\nI believe with this fix, front-run can still be done.  It is better to check if the pair exists, then simply don\u2019t create it. This way, there is zero DoS.",
        "severity": "high",
        "reason": "No unmatched tool findings remaining"
      },
      {
        "id": "code4rena_lambowin_2025_02_expected_002",
        "title": "Calculation fordirectionMaskis incorrect",
        "description": "Submitted by\n0xleadwizard\n, also found by\nAgontuk\n,\nBenRai\n,\nInfect3d\n,\nJiri123\n,\nNexusAudits\n,\nRhaydden\n,\nrouhsamad\n,\nSpicyMeatball\n, and\nZhengZuo999\n\nhttps://github.com/code-423n4/2024-12-lambowin/blob/main/src/rebalance/LamboRebalanceOnUniwap.sol#L165\n\nThe\n_getQuoteAndDirection\nfunction\u2019s flawed logic can cause incorrect direction determination in the UniswapV3 pool. The recommended mitigation ensures that the function dynamically identifies token0 and token1 and assigns the correct direction mask. This prevents potential financial losses and ensures accurate rebalancing.\n\nThe function\npreviewRebalance\nis called off-chain, to calculate values that can be passed to the function\nrebalance\nwhen making a call for balancing the uniswapV3 vETH/WETH pool.\n\nfunction\npreviewRebalance\n()\npublic\nview\nreturns\n(\nbool\nresult\n,\nuint256\ndirectionMask\n,\nuint256\namountIn\n,\nuint256\namountOut\n)\n{\naddress\ntokenIn\n;\naddress\ntokenOut\n;\n(\ntokenIn\n,\ntokenOut\n,\namountIn\n) =\n_getTokenInOut\n();\n(\namountOut\n,\ndirectionMask\n) =\n_getQuoteAndDirection\n(\ntokenIn\n,\ntokenOut\n,\namountIn\n);\nresult\n=\namountOut\n>\namountIn\n;\n}\n\nThe function\n_getQuoteAndDirection\ntakes\ntokenIn\n,\ntokenOut\n&\namountIn\nas parameter to output\namountOut\n&\ndirectionMask\n.\n\ndirectionMask\nis used to decide if the swap is\nzero-for-one\nor\none-for-zero\nin OKX.\n\nThe\n_getQuoteAndDirection\nfunction assumes that WETH is always token1, which can lead to incorrect direction determination in cases where WETH is actually token0. This is due to the fact that Uniswap sorts token0 and token1 lexicographically by their addresses, and not based on their logical roles.\n\nfunction\n_getQuoteAndDirection\n(\naddress\ntokenIn\n,\naddress\ntokenOut\n,\nuint256\namountIn\n)\ninternal\nview\nreturns\n(\nuint256\namountOut\n,\nuint256\ndirectionMask\n) {\n(\namountOut\n, , , ) =\nIQuoter\n(\nquoter\n).\nquoteExactInputSingleWithPool\n(\nIQuoter\n.\nQuoteExactInputSingleWithPoolParams\n({\ntokenIn:\ntokenIn\n,\ntokenOut:\ntokenOut\n,\namountIn:\namountIn\n,\nfee:\nfee\n,\npool:\nuniswapPool\n,\nsqrtPriceLimitX96:\n0\n})\n);\n>>\ndirectionMask\n= (\ntokenIn\n==\nweth\n) ?\n_BUY_MASK\n:\n_SELL_MASK\n;\n}\n\nExample: If the UniswapV3 pool has token0 as WETH (lower address value) and token1 as vETH (higher address value), and the pool has more vETH than WETH, the tokenIn will be WETH. However, because WETH is token0 in this case, the correct direction would be zero-for-one. The current logic mistakenly assumes WETH is token1, leading to an incorrect direction of one-for-zero.\n\nFor context, here is how the MASK is used in OKX:\n\nMASK defined\n\nuint256\nprivate\nconstant\n_ONE_FOR_ZERO_MASK\n=\n1\n<<\n255\n;\n// Mask for identifying if the swap is one-for-zero\n\nMASK used\n\nlet\nzeroForOne\n:=\neq\n(\nand\n(\n_pool\n,\n_ONE_FOR_ZERO_MASK\n),\n0\n)\n\nAdd the logic for considering if the\ntokenIn\nis\ntoken0\nor\ntoken1\n.\n\nfunction\n_getQuoteAndDirection\n(\naddress\ntokenIn\n,\naddress\ntokenOut\n,\nuint256\namountIn\n)\ninternal\nview\nreturns\n(\nuint256\namountOut\n,\nuint256\ndirectionMask\n) {\n// Retrieve token0 and token1 from the Uniswap pool\naddress\ntoken0\n=\nIUniswapV3Pool\n(\nuniswapPool\n).\ntoken0\n();\naddress\ntoken1\n=\nIUniswapV3Pool\n(\nuniswapPool\n).\ntoken1\n();\n// Call the quoter to get the amountOut\n(\namountOut\n, , , ) =\nIQuoter\n(\nquoter\n).\nquoteExactInputSingleWithPool\n(\nIQuoter\n.\nQuoteExactInputSingleWithPoolParams\n({\ntokenIn:\ntokenIn\n,\ntokenOut:\ntokenOut\n,\namountIn:\namountIn\n,\nfee:\nfee\n,\npool:\nuniswapPool\n,\nsqrtPriceLimitX96:\n0\n})\n);\n// Determine directionMask based on tokenIn position (token0 or token1)\nif\n(\ntokenIn\n==\ntoken0\n) {\ndirectionMask\n=\n_SELL_MASK\n;\n// Zero-for-one direction\n}\nelse\n{\ndirectionMask\n=\n_BUY_MASK\n;\n// One-for-zero direction\n}\n}\n\nShaneson (Lambo.win) acknowledged and commented\n:\n\nWhen the VETH is deployed, the direction will be updated. But yes, this is still a good suggestion.",
        "severity": "high",
        "reason": "No unmatched tool findings remaining"
      },
      {
        "id": "code4rena_lambowin_2025_02_expected_003",
        "title": "Anyone can callLamboRebalanceOnUniwap.sol::rebalance()function with any arbitrary value, leading to rebalancing goal i.e. (1:1 peg) unsuccessful.",
        "description": "Submitted by\norangesantra\n, also found by\nEPSec\nand\nEvo\n\nAnyone can call\nLamboRebalanceOnUniwap.sol::rebalance()\nfunction with any arbitrary value, leading to rebalancing goal i.e. (1:1 peg) unsuccessful.\n\nThe parameters required in\nrebalance()\nfunction will are,\nuint256 directionMask\n,\nuint256 amountIn\n,\nuint256 amountOut\n. The typical value should be -\n\ndirectionMask =\n0\nor\n1<<255\n\namountIn and amountOut obtained from\nLamboRebalanceOnUniwap.sol::previewRebalance()\n\nBut since there is no check, to ensure the typical values of parameter in the function, this can cause the flashloan for wrong amount or flashloan reverting if directionMask is any other value apart from\n0\nor\n1<<255\n.\n\nIf flashloan of wrong amount occurs it means the pool will be unbalanced again with different value instead of balancing.\n\nBy pasting the following code in\nRebalanceTest.t.sol\n, we can see that\nafter_uniswapPoolWETHBalance:2\nand\nafter_uniswapPoolVETHBalance:2\nare much distant.\n\nThe test does the following -\n\nDo the usual rebalancing operation by executing\nrebalance()\n, by proving parameter from\npreviewRebalance()\nand legit\ndirectionMask\n.\nAfter snapshot revert, it calls the\nrebalance()\nfunction from an unauthorised user with an abritrary value.\nIn the console log we can see, that the rebalance with typical parameters does the balancing goal of nearly 1:1\n\n// after_uniswapPoolWETHBalance:  449788833045085369301\n// after_uniswapPoolVETHBalance:  452734978359843468645\n\nBut for second part output statement obtained is as follow (unable to obtain 1:1 peg)-\n\n// after_uniswapPoolWETHBalance:2  350165415961266006942\n// after_uniswapPoolVETHBalance:2  552734978359843468645\n\nPaste the below code in RebalanceTest.t.sol.\n\nfunction test_any_caller() public {\nuint256 amount = 422 ether;\nuint256 _v3pool = uint256(uint160(uniswapPool)) | (_ONE_FOR_ZERO_MASK);\nuint256[] memory pools = new uint256[](1);\npools[0] = _v3pool;\nuint256 amountOut0 = IDexRouter(OKXRouter).uniswapV3SwapTo{value: amount}(\nuint256(uint160(multiSign)),\namount,\n0,\npools\n);\nconsole.log(\"user amountOut0\", amountOut0);\n(bool result, uint256 directionMask, uint256 amountIn, uint256 amountOut) = lamboRebalance.previewRebalance();\nrequire(result, \"Rebalance not profitable\");\nuint256 before_uniswapPoolWETHBalance = IERC20(WETH).balanceOf(uniswapPool);\nuint256 before_uniswapPoolVETHBalance = IERC20(VETH).balanceOf(uniswapPool);\nuint snapshot = vm.snapshot();\nlamboRebalance.rebalance(directionMask, amountIn, amountOut);\nuint256 initialBalance = IERC20(WETH).balanceOf(address(this));\nlamboRebalance.extractProfit(address(this), WETH);\nuint256 finalBalance = IERC20(WETH).balanceOf(address(this));\nrequire(finalBalance > initialBalance, \"Profit must be greater than 0\");\nconsole.log(\"profit :\", finalBalance - initialBalance);\nuint256 after_uniswapPoolWETHBalance = IERC20(WETH).balanceOf(uniswapPool);\nuint256 after_uniswapPoolVETHBalance = IERC20(VETH).balanceOf(uniswapPool);\n// profit : 2946145314758099343\n// before_uniswapPoolWETHBalance:  872000000000000000000\n// before_uniswapPoolVETHBalance:  33469956719686937289\n// after_uniswapPoolWETHBalance:  449788833045085369301\n// after_uniswapPoolVETHBalance:  452734978359843468645\nconsole.log(\"before_uniswapPoolWETHBalance: \", before_uniswapPoolWETHBalance);\nconsole.log(\"before_uniswapPoolVETHBalance: \", before_uniswapPoolVETHBalance);\nconsole.log(\"after_uniswapPoolWETHBalance: \", after_uniswapPoolWETHBalance);\nconsole.log(\"after_uniswapPoolVETHBalance: \", after_uniswapPoolVETHBalance);\nvm.revertTo(snapshot);\n// creating a non-authorised address.\nuint256 signerPrivateKey = 0xabc123;\naddress signer = vm.addr(signerPrivateKey);\ndeal(WETH, signer, amountIn + 100 ether);\ndeal(VETH, signer, amountOut + 100 ether);\nvm.startPrank(signer);\nlamboRebalance.rebalance(directionMask, amountIn + 100 ether, amountOut + 100 ether);\nvm.stopPrank();\ninitialBalance = IERC20(WETH).balanceOf(address(this));\nlamboRebalance.extractProfit(address(this), WETH);\nfinalBalance = IERC20(WETH).balanceOf(address(this));\nrequire(finalBalance > initialBalance, \"Profit must be greater than 0\");\nconsole.log(\"profit :\", finalBalance - initialBalance);\nafter_uniswapPoolWETHBalance = IERC20(WETH).balanceOf(uniswapPool);\nafter_uniswapPoolVETHBalance = IERC20(VETH).balanceOf(uniswapPool);\n// profit : 2569562398577461702\n// before_uniswapPoolWETHBalance:2  872000000000000000000\n// before_uniswapPoolVETHBalance:2  33469956719686937289\n// after_uniswapPoolWETHBalance:2  350165415961266006942\n// after_uniswapPoolVETHBalance:2  552734978359843468645\nconsole.log(\"before_uniswapPoolWETHBalance:2 \", before_uniswapPoolWETHBalance);\nconsole.log(\"before_uniswapPoolVETHBalance:2 \", before_uniswapPoolVETHBalance);\nconsole.log(\"after_uniswapPoolWETHBalance:2 \", after_uniswapPoolWETHBalance);\nconsole.log(\"after_uniswapPoolVETHBalance:2 \", after_uniswapPoolVETHBalance);\nrequire(\n((before_uniswapPoolWETHBalance + before_uniswapPoolVETHBalance) -\n(after_uniswapPoolWETHBalance + after_uniswapPoolVETHBalance) ==\n(finalBalance - initialBalance)),\n\"Rebalance Profit comes from pool's rebalance\"\n);\n}\n\nCheck the parameter of\nrebalance()\nfunction whether they are legit or not, i.e. as per flashloan requirement.\n\nShaneson (Lambo.win) acknowledged",
        "severity": "high",
        "reason": "No unmatched tool findings remaining"
      }
    ],
    "extra_findings": [],
    "undecided_findings": []
  }
}