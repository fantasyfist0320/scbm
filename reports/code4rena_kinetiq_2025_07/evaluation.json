{
  "agent_execution_id": 1,
  "project": "code4rena_kinetiq_2025_07",
  "status": "Status.SUCCESS",
  "result": {
    "project": "code4rena_kinetiq_2025_07",
    "timestamp": "2026-02-03T20:49:00.555603",
    "total_expected": 3,
    "total_found": 0,
    "true_positives": 0,
    "false_negatives": 3,
    "false_positives": 0,
    "detection_rate": 0.0,
    "result": "FAIL",
    "precision": 0.0,
    "f1_score": 0.0,
    "matched_findings": [],
    "missed_findings": [
      {
        "id": "code4rena_kinetiq_2025_07_expected_000",
        "title": "Buffer Silently Locks Staked HYPE in Contract Without Using Them For Withdrawals Or Providing A Way To Be Pulled Out Or Moved To L1",
        "description": "Submitted by\nfranfran20\n, also found by\n0xDeoGratias\n,\n0xG0P1\n,\n0xgremlincat\n,\n0xpiken\n,\n0xsagetony\n,\ndobrevaleri\n,\ngesha17\n,\nhals\n,\nInfect3d\n,\nka14ar\n,\nKupiaSec\n,\nmarchev\n,\nRagnarok\n,\nrama_tavanam\n,\nRiceee\n,\nroccomania\n,\nrouhsamad\n,\nzhanmingjing\n, and\nzhaojohnson\n\nhttps://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L946-L957\n\nhttps://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L919-L941\n\nhttps://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L519-L533\n\nWhen users stake into the Staking Manager and get their KHYPE tokens, after earning some rewards they might want to queue a withdrawal to get their HYPE tokens back. While the queued withdrawal delay is on, the user can decide to\ncancelWithdrawal\nand get their KHYPE tokens back. The way the buffer is handled in this flow leads to locking of HYPE in the staking manager contract.\n\nTake for example a target buffer of\n30 HYPE\nwith only\n20 HYPE\nleft in the buffer, the user has initially staked some HYPE and gotten some KHYPE.\n\nThe user wishes to cash in that KHYPE worth\n15 HYPE\n, now the buffer can satisfy this amount of HYPE, so they\u2019ll need to withdraw from the validator on L1. You can see this in the\n_withdrawFromValidator\nfunction UserWithdrawal operation type below.\n\nif\n(\noperationType\n==\nOperationType\n.\nUserWithdrawal\n) {\n// Buffer handling uses 18 decimal precision\nuint256\ncurrentBuffer\n=\nhypeBuffer\n;\nuint256\namountFromBuffer\n=\nMath\n.\nmin\n(\namount\n,\ncurrentBuffer\n);\nif\n(\namountFromBuffer\n>\n0\n) {\nhypeBuffer\n=\ncurrentBuffer\n-\namountFromBuffer\n;\namount\n-=\namountFromBuffer\n;\nemit\nBufferDecreased\n(\namountFromBuffer\n,\nhypeBuffer\n);\n}\n// If fully fulfilled from buffer, return\nif\n(\namount\n==\n0\n) {\nreturn\n;\n}\n}\n\nSo the buffer reduces to\n5 HYPE\n(even though the contract still has the remaining\n15 HYPE\nbecause the transfer hasn\u2019t occurred yet) and the withdrawal amount is fully satisfied, with the withdrawal request being created.  Ideally, the user now has to wait the withdrawal delay and confirm their withdrawal but if at some point during the withdrawal delay, the user decides to cancel their withdrawal and keep their KHYPE tokens. We can observe the function below.\n\nfunction\ncancelWithdrawal\n(\naddress\nuser\n,\nuint256\nwithdrawalId\n)\nexternal\nonlyRole\n(\nMANAGER_ROLE\n)\nwhenNotPaused\n{\nWithdrawalRequest\nstorage\nrequest\n=\n_withdrawalRequests\n[\nuser\n][\nwithdrawalId\n];\nrequire\n(\nrequest\n.\nhypeAmount\n>\n0\n,\n\"No such withdrawal request\"\n);\nuint256\nhypeAmount\n=\nrequest\n.\nhypeAmount\n;\nuint256\nkHYPEAmount\n=\nrequest\n.\nkHYPEAmount\n;\nuint256\nkHYPEFee\n=\nrequest\n.\nkHYPEFee\n;\n// Check kHYPE balances\nrequire\n(\nkHYPE\n.\nbalanceOf\n(\naddress\n(\nthis\n)) >=\nkHYPEAmount\n+\nkHYPEFee\n,\n\"Insufficient kHYPE balance\"\n);\n// Clear the withdrawal request\ndelete\n_withdrawalRequests\n[\nuser\n][\nwithdrawalId\n];\ntotalQueuedWithdrawals\n-=\nhypeAmount\n;\n// Return kHYPE tokens to user (including fees)\nkHYPE\n.\ntransfer\n(\nuser\n,\nkHYPEAmount\n+\nkHYPEFee\n);\n// Track cancelled amount for future redelegation\n_cancelledWithdrawalAmount\n+=\nhypeAmount\n;\nemit\nWithdrawalCancelled\n(\nuser\n,\nwithdrawalId\n,\nhypeAmount\n,\n_cancelledWithdrawalAmount\n);\n}\n\nThere is no update to increment the buffer back after the withdrawal has been canceled, so the\n15 HYPE\ntokens are stored in the balance and are tracked in the\n_cancelledWithdrawalAmount\nwhich eventually can be moved via the\nredelegateWithdrawnHYPE\nfunction below.\n\nfunction\nredelegateWithdrawnHYPE\n()\nexternal\nonlyRole\n(\nMANAGER_ROLE\n)\nwhenNotPaused\n{\nrequire\n(\n_cancelledWithdrawalAmount\n>\n0\n,\n\"No cancelled withdrawals\"\n);\nrequire\n(\naddress\n(\nthis\n).\nbalance\n>=\n_cancelledWithdrawalAmount\n,\n\"Insufficient HYPE balance\"\n);\nuint256\namount\n=\n_cancelledWithdrawalAmount\n;\n_cancelledWithdrawalAmount\n=\n0\n;\n// Delegate to current validator using the SpotDeposit operation type\n_distributeStake\n(\namount\n,\nOperationType\n.\nSpotDeposit\n);\nemit\nWithdrawalRedelegated\n(\namount\n);\n}\n\nNow we can see that the function calls the distributeStake internal function with a spot deposit operation type and it resets the\n_cancelledWithdrawableAmount\nto 0, meaning the\n15 HYPE\nthat was initially taken from the buffer and canceled is no longer accounted for because it\u2019s going to be redelegated to the validators.\n\nelse\nif\n(\noperationType\n==\nOperationType\n.\nSpotDeposit\n) {\n// For spot deposits, first move from spot balance to staking balance\nuint256\ntruncatedAmount\n=\n_convertTo8Decimals\n(\namount\n,\nfalse\n);\nrequire\n(\ntruncatedAmount\n<=\ntype\n(\nuint64\n).\nmax\n,\n\"Amount exceeds uint64 max\"\n);\n// 1. First move from spot balance to staking balance using cDeposit\nl1Write\n.\nsendCDeposit\n(\nuint64\n(\ntruncatedAmount\n));\n// 2. Queue the delegation operation (8 decimals)\n_queueL1Operation\n(\nvalidator\n,\ntruncatedAmount\n,\nOperationType\n.\nRebalanceDeposit\n);\n}\n\nThis basically converts the amount to 8 decimals and moves it from the spot balance in L1 to the staking balance. Now the issue arises from the fact that the withdrawn funds were taken from the buffer and the withdrawal amount never got to L1. My understanding of the connection between the HYPER core and EVM is that the funds need to be moved first to L1 as with the user deposit operation with the logic below before being moved from spot to staking balance on L1.\n\n(\nbool\nsuccess\n,) =\npayable\n(\nL1_HYPE_CONTRACT\n).\ncall\n{value:\namount\n}(\n\"\"\n);\nrequire\n(\nsuccess\n,\n\"Failed to send HYPE to L1\"\n);\n\nHence the\n15 HYPE\ngets lost in the process and it can be repeated over and over again.\n\nEnsure that when the the canceled withdrawn amount is taken from the buffer, the buffer is either re-bumped or the assets are first moved to L1 to avoid being locked in the staking manager contract.\n\nKinetiq disputed and commented:\n\nWe can reduce the target buffer to zero to clear it as withdrawal liquidity.\nAlternatively we are able to redelegate those cancelled withdrawals back to protocol by using\nredelegateWithdrawnHYPE\n.",
        "severity": "high",
        "reason": "No unmatched tool findings remaining"
      },
      {
        "id": "code4rena_kinetiq_2025_07_expected_001",
        "title": "Users Who Queue Withdrawal Before A Slashing Event Disadvantage Users Who Queue After And Eventually Leads To Loss Of Funds For Them",
        "description": "Submitted by\nfranfran20\n, also found by\n0xG0P1\n,\n0xLeveler\n,\n0xpiken\n,\nadamIdarrha\n,\nAfriauditor\n,\nak1\n,\nAtharv\n,\nAudinarey\n,\nbtk\n,\nd3e4\n,\nfalconhoof\n,\ngesha17\n,\ngivn\n,\nharry\n,\nholydevoti0n\n,\nIzuMan\n,\nke1caM\n,\nknight18695\n,\nkomronkh\n,\nKupiaSec\n,\nmarchev\n,\nmrudenko\n,\nMrValioBg\n,\nocteezy\n,\noxelmiguel12\n,\npeanuts\n,\nphoenixV110\n,\nrouhsamad\n,\nThanatOS\n,\ntrachev\n,\ntypicalHuman\n,\nvangrim\n,\nzhaojohnson\n, and\nzzebra83\n\nhttps://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingAccountant.sol#L214-L216\n\nLets take the scenario where the HYPE to KHYPE exchange is\n1 KHYPE = 1.5 KHYPE\n.\n\nAt this point, let\u2019s assume that there are in total\n50 KHYPE\ntokens queued for withdrawals, that is\n75 HYPE\nqueued for withdrawals while the remaining\n20 KHYPE\nare still held by their respective holders worth\n30 HYPE\nin all.\n\nThis means that the locked in amount in the queued Withdrawals for each user across all queued withdrawals is\n75 HYPE\n.\n\nWe know this because of the logic in the queueWithdrawal function in the StakingManager below:\n\nuint256\nhypeAmount\n=\nstakingAccountant\n.\nkHYPEToHYPE\n(\npostFeeKHYPE\n);\n// Lock kHYPE tokens\nkHYPE\n.\ntransferFrom\n(\nmsg\n.\nsender\n,\naddress\n(\nthis\n),\nkHYPEAmount\n);\n// Create withdrawal request\n_withdrawalRequests\n[\nmsg\n.\nsender\n][\nwithdrawalId\n] =\nWithdrawalRequest\n({\nhypeAmount:\nhypeAmount\n,\nkHYPEAmount:\npostFeeKHYPE\n,\nkHYPEFee:\nkHYPEFee\n,\ntimestamp:\nblock\n.\ntimestamp\n});\n\nThat gives us a total of\n70 KHYPE\nto\n105 HYPE\nacross the board when calulating the exchange ratio (including rewards).\n\nNow let\u2019s assume for some reason there\u2019s a slashing event and the amount of HYPE in total reduces from\n105 KHYPE\nto\n75 KHYPE\n.\n\nNow it leaves us with an exchange ratio of\n70 KHYPE\nto\n75 HYPE\ni.e\n1 KHYPE = 1.071 HYPE\n.\n\nSince the guys who withdrew earlier already have their withdrawal delay processing first locked in with the ratio that was used before the slash, they all successfully confirm their withdrawal first and take the whole\n75 HYPE\navailable, leaving 0 HYPE left for all the remaining\n20 KHYPE\nholders.\n\nYou can see the\nconfirmWithdrawal\nfunction uses the withdrawalRequest amount\nhypeAmount\nstored which uses the previous ratio.\n\nfunction\nconfirmWithdrawal\n(\nuint256\nwithdrawalId\n)\nexternal\nnonReentrant\nwhenNotPaused\n{\n// @note - the process confirmation basically makes sure the khype amount to be withdrawn is in the contracts\n// ... it burns it, transfers the fee and makes sure the withdrawal delay has been exceeded, deletes the withdrawal request, updates the totalclaimed and totalqueuedwithdrawals\n// ... it then returns the hype amount to be received by the user\nuint256\namount\n=\n_processConfirmation\n(\nmsg\n.\nsender\n,\nwithdrawalId\n);\nrequire\n(\namount\n>\n0\n,\n\"No valid withdrawal request\"\n);\n// @note - makes sure that the contract has the specified amount required to satisfy the withdrawals\n// @note - this is where the issue lies I guess, maybe not here, but if there was a slashing occurence before this confirmation of withdrawal, there could be an issue???\nrequire\n(\naddress\n(\nthis\n).\nbalance\n>=\namount\n,\n\"Insufficient contract balance\"\n);\n// @note - updates the totalClaimed hype across all SM\nstakingAccountant\n.\nrecordClaim\n(\namount\n);\n// Process withdrawal using call instead of transfer\n(\nbool\nsuccess\n,) =\npayable\n(\nmsg\n.\nsender\n).\ncall\n{value:\namount\n}(\n\"\"\n);\nrequire\n(\nsuccess\n,\n\"Transfer failed\"\n);\n}\n\nThis leads to loss of stake for the remaining KHYPE holders even though there was enough to go 1:1.\n\nA possible mitigation would be when confirming withdrawals, not to use the hypeAmount stored in the withdrawal request but to recalculate with the new ratio.\n\nKinetiq disputed and commented:\n\nExchange rate adjusts only during rewards or slashing. When users queue withdrawals, their assets exit the validator, earning no profits, so the exchange rate remains fixed as when queued, until confirmation. The rate fluctuates slightly upon claiming due to total supply changes, but this is acceptable and not an issue for us.",
        "severity": "high",
        "reason": "No unmatched tool findings remaining"
      },
      {
        "id": "code4rena_kinetiq_2025_07_expected_002",
        "title": "Mishandling of receiving HYPE in the StakingManager, user can\u2019t confirm withdrawal and inflate the exchange ratio",
        "description": "Submitted by\n0xDemon\n, also found by\n0xG0P1\n,\nchibi\n,\nFalendar\n,\nFalseGenius\n,\nIzuMan\n,\njkk812812\n,\nLSHFGJ\n,\noxelmiguel12\n,\nRiceee\n,\nroccomania\n, and\nwon\n\nhttps://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L208-L211\n\nMishandling of receiving\nHYPE\nin the\nStakingManager\n, user can\u2019t confirm withdrawal and inflate the exchange ratio.\n\nBased on the\nHyperliquid docs\n:\n\nHYPE is a special case as the native gas token on the HyperEVM. HYPE is received on the EVM side of a transfer as the native gas token instead of an ERC20 token\n\nThe problem arises when\nHYPE\nwithdrawn from a validator on Hypercore is sent to the\nStakingManager\n(e.g. use call / transfer). It will immediately trigger the\nstake()\nfunction to be called and cause the\nHYPE\nthat should have been sent to the user who made the withdrawal to be staked back and inflate the exchange ratio. This happened because of the implementation of\nreceive()\non the\nStakingManager\n:\n\nreceive\n()\nexternal\npayable\n{\n// Simply call the stake function\nstake\n();\n}\n\nThe first impact can occur if\ntargetBuffer = 0\n, but there is another impact if\ntargetBuffer != 0\nand fully fulfill.\n\nIf the buffer is applied, the user who initiated the withdrawal can still confirm the withdrawal but there is another effect that arises, the\nHYPE\nresulting from the withdrawal is still staked and inflates the exchange ratio for\nHYPE\nand\nKHYPE\nbecause\nKHYPE\nwill be minted to the system address (Core) and the\ntotalSupply\nwill increase. The amount of\nKHYPE\nminted to system address will be locked forever.\n\nNote: This issue could also happen if reward from delegating to validator is sent directly to\nStakingManager\n.\n\nModify the\nreceive()\nfunction\n\nreceive\n()\nexternal\npayable\n{\n// Simply call the stake function\nif\n(\nmsg\n.\nsender\n!=\nsystemAddress\n) {\nstake\n();\n}\n}\n\nThe\nschema\nfor\nthe\ntest :\n1.\nWill\nuse\ntargetBuffer\n=\n0\nfor\nsimplicity\n2.\nUser\nstake\n1\nHYPE\n3.\nOperator\nexecute\nL1\ndeposit\noperations\n4.\nUser\nqueue\nwithdrawal\n,\n1\nKHYPE\n5.\nOperator\nexecute\nL1\nwithdrawal\noperations\n6.\nSystem\naddress\n(\nCore\n)\ncall\n/\ntransfer\nHYPE\nto\nstaking\nmanager\nand\nauto\nstaked\n7.\nUser\ncan\n't confirm withdrawal because lack of HYPE balance on the staking manage\nr\n\nAdd test to\nStakingManager.t.sol\nand run\nforge test --match-test test_misshandlingOfReceivingHYPE -vvv\n\nfunction\ntest_misshandlingOfReceivingHYPE\n()\npublic\n{\n// Set actor\naddress\nsystemAddressForHYPE\n=\nmakeAddr\n(\n\"systemAddressForHYPE\"\n);\n// Set staking amount\nuint256\nstakeAmount\n=\n1\nether\n;\n// fund the system for mocking withdrawal process and the user\nvm\n.\ndeal\n(\nsystemAddressForHYPE\n,\n1\nether\n);\nvm\n.\ndeal\n(\nuser\n,\n1\nether\n);\n// Set up delegation first\nvm\n.\nstartPrank\n(\nmanager\n);\nvalidatorManager\n.\nactivateValidator\n(\nvalidator\n);\nvalidatorManager\n.\nsetDelegation\n(\naddress\n(\nstakingManager\n),\nvalidator\n);\nvm\n.\nstopPrank\n();\nconsole\n.\nlog\n(\n\"\"\n);\nconsole\n.\nlog\n(\n\" START TEST ... \"\n);\nconsole\n.\nlog\n(\n\"\"\n);\n// check stakingManager balance\nuint256\ninitialStakingManagerBalance\n=\naddress\n(\nstakingManager\n).\nbalance\n;\nconsole\n.\nlog\n(\n\"Staking Manager Initial HYPE Balance:\"\n,\ninitialStakingManagerBalance\n);\nconsole\n.\nlog\n(\n\"\"\n);\nconsole\n.\nlog\n(\n\" USER STAKE ... \"\n);\nconsole\n.\nlog\n(\n\"\"\n);\n// User stake\nvm\n.\nprank\n(\nuser\n);\nstakingManager\n.\nstake\n{value:\nstakeAmount\n}();\nuint256\nstakingManagerBalanceAfterUserDeposit\n=\naddress\n(\nstakingManager\n).\nbalance\n;\nconsole\n.\nlog\n(\n\"\n\\\\\nThis value will be zero because HYPE will directly send to system address on core\"\n);\nconsole\n.\nlog\n(\n\"Staking Manager HYPE Balance After User Deposit:\"\n,\nstakingManagerBalanceAfterUserDeposit\n);\nconsole\n.\nlog\n(\n\"\"\n);\nconsole\n.\nlog\n(\n\" OPERATOR EXECUTE L1 DEPOSIT OPERATION ... \"\n);\nconsole\n.\nlog\n(\n\"\"\n);\n// operator execute L1 operations : delegate HYPE to validator\nvm\n.\nprank\n(\noperator\n);\nstakingManager\n.\nprocessL1Operations\n(\n0\n);\nconsole\n.\nlog\n(\n\" USER QUEUE WITHDRAWAL ... \"\n);\nconsole\n.\nlog\n(\n\"\"\n);\n// User withdraw\nvm\n.\nstartPrank\n(\nuser\n);\nkHYPE\n.\napprove\n(\naddress\n(\nstakingManager\n),\nstakeAmount\n);\nstakingManager\n.\nqueueWithdrawal\n(\nstakeAmount\n);\nvm\n.\nstopPrank\n();\nconsole\n.\nlog\n(\n\" OPERATOR EXECUTE L1 WITHDRAWAL OPERATION ... \"\n);\nconsole\n.\nlog\n(\n\"\"\n);\n// operator execute L1 operations : undelegated HYPE from validator\nvm\n.\nprank\n(\noperator\n);\nstakingManager\n.\nprocessL1Operations\n(\n0\n);\nconsole\n.\nlog\n(\n\" WITHDRAWAL HYPE FROM CORE SEND TO STAKINGMANAGER ... \"\n);\nconsole\n.\nlog\n(\n\"\"\n);\n// systemAddress send back undelegated HYPE from validator to stakingManager\nvm\n.\nprank\n(\nsystemAddressForHYPE\n);\naddress\n(\nstakingManager\n).\ncall\n{value :\nstakeAmount\n}(\n\"\"\n);\nuint256\nstakingManagerBalanceAfterHYPESentFromCore\n=\naddress\n(\nstakingManager\n).\nbalance\n;\nconsole\n.\nlog\n(\n\"\n\\\\\nThis value will be zero, HYPE will directly stacked again because receive() initiate stake() function\"\n);\nconsole\n.\nlog\n(\n\"Staking Manager HYPE Balance After HYPE Sent From Core :\"\n,\nstakingManagerBalanceAfterHYPESentFromCore\n);\n// warp 7 days\nvm\n.\nwarp\n(\nblock\n.\ntimestamp\n+\n7\ndays\n);\n// User want to confirm withdrawal failed because lack of HYPE on stakingManager\nvm\n.\nprank\n(\nuser\n);\nvm\n.\nexpectRevert\n();\nstakingManager\n.\nconfirmWithdrawal\n(\n0\n);\n}\n\nResult:\n\n[\nPASS\n]\ntest_misshandlingOfReceivingHYPE\n() (\ngas\n:\n897229\n)\nLogs:\nStarting setUp\nMinimal implementation deployed at: 0x2e234DAe75C793f67A35089C9d99245E1C58470b\nDeploying proxies...\nPauserRegistry proxy deployed at: 0xF62849F9A0B5Bf2913b396098F7c7019b51A820a\nPauserRegistry admin at: 0x4f81992FCe2E1846dD528eC0102e6eE1f61ed3e2\nStakingManager proxy deployed at: 0x5991A2dF15A8F6A256D3Ec51E99254Cd3fb576A9\nStakingManager admin at: 0x5B0091f49210e7B2A57B03dfE1AB9D08289d9294\nKHYPE proxy deployed at: 0xc7183455a4C133Ae270771860664b6B7ec320bB1\nKHYPE admin at: 0xa38D17ef017A314cCD72b8F199C0e108EF7Ca04c\nValidatorManager proxy deployed at: 0xa0Cb889707d426A7A386870A03bc70d1b0697598\nValidatorManager admin at: 0x83B4EEa426B7328eB3bE89cDb558F18BAF6A2Bf7\nOracleManager proxy deployed at: 0x1d1499e622D69689cdf9004d05Ec547d650Ff211\nOracleManager admin at: 0x45C92C2Cd0dF7B2d705EF12CfF77Cb0Bc557Ed22\nStakingAccountant proxy deployed at: 0xA4AD4f68d0b91CFD19687c881e50f3A00242828c\nStakingAccountant admin at: 0xeafCcCE3F73a1ac8690F49acF56C4142183619dd\nStarted admin prank\nCreating pausable contracts array\nSetup completed\nSTART TEST ...\nStaking Manager Initial HYPE Balance: 0\nUSER STAKE ...\n\\ This value will be zero because HYPE will directly send to system address on core\nStaking Manager HYPE Balance After User Deposit: 0\nOPERATOR EXECUTE L1 DEPOSIT OPERATION ...\nUSER QUEUE WITHDRAWAL ...\nOPERATOR EXECUTE L1 WITHDRAWAL OPERATION ...\nWITHDRAWAL HYPE FROM CORE SEND TO STAKINGMANAGER ...\n\\ This value will be zero, HYPE will directly stacked again because receive() initiate stake() function\nStaking Manager HYPE Balance After HYPE Sent From Core : 0\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 8.41ms (1.93ms\nCPU\ntime\n)\n\nKinetiq acknowledged",
        "severity": "high",
        "reason": "No unmatched tool findings remaining"
      }
    ],
    "extra_findings": [],
    "undecided_findings": []
  }
}