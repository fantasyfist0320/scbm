{
  "agent_execution_id": 1,
  "project": "code4rena_bakerfi-invitational_2025_02",
  "status": "Status.SUCCESS",
  "result": {
    "project": "code4rena_bakerfi-invitational_2025_02",
    "timestamp": "2026-02-03T20:50:29.634145",
    "total_expected": 7,
    "total_found": 0,
    "true_positives": 0,
    "false_negatives": 7,
    "false_positives": 0,
    "detection_rate": 0.0,
    "result": "FAIL",
    "precision": 0.0,
    "f1_score": 0.0,
    "matched_findings": [],
    "missed_findings": [
      {
        "id": "code4rena_bakerfi-invitational_2025_02_expected_000",
        "title": "Users may encounter losses on assets deposited throughStrategySupplyERC4626",
        "description": "Submitted by\n0xpiken\n, also found by\n0xlemon\n,\nklau5\n,\nklau5\n,\nMrPotatoMagic\n, and\nshaflow2\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/strategies/StrategySupplyERC4626.sol#L44\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/strategies/StrategySupplyERC4626.sol#L51\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/strategies/StrategySupplyERC4626.sol#L58\n\nThe\n_deploy()\n,\n_undeploy()\n, and\n_getBalance()\nfunctions of\nStrategySupplyERC4626\ncurrently return the amount of shares instead of the amount of the underlying asset. This mistake leads to incorrect calculations of user assets within any BakerFi Vault that utilizes\nStrategySupplyERC4626\n.\n\nWhen a user deposits a certain amount of asset (\ndeployedAmount\n) into a BakerFi vault, it is deployed into the vault\u2019s underlying strategies. In return, the user receives a corresponding number of\nshares\n:\n\nfunction\n_depositInternal\n(\nuint256\nassets\n,\naddress\nreceiver\n)\nprivate\nreturns\n(\nuint256\nshares\n) {\nif\n(\nreceiver\n==\naddress\n(\n0\n))\nrevert\nInvalidReceiver\n();\n// Fetch price options from settings\n// Get the total assets and total supply\nRebase\nmemory\ntotal\n=\nRebase\n(\ntotalAssets\n(),\ntotalSupply\n());\n// Check if the Rebase is uninitialized or both base and elastic are positive\nif\n(!((\ntotal\n.\nelastic\n==\n0\n&&\ntotal\n.\nbase\n==\n0\n) || (\ntotal\n.\nbase\n>\n0\n&&\ntotal\n.\nelastic\n>\n0\n))) {\nrevert\nInvalidAssetsState\n();\n}\n// Check if deposit exceeds the maximum allowed per wallet\nuint256\nmaxDepositLocal\n=\ngetMaxDeposit\n();\nif\n(\nmaxDepositLocal\n>\n0\n) {\nuint256\ndepositInAssets\n= (\nbalanceOf\n(\nmsg\n.\nsender\n) *\n_ONE\n) /\ntokenPerAsset\n();\nuint256\nnewBalance\n=\nassets\n+\ndepositInAssets\n;\nif\n(\nnewBalance\n>\nmaxDepositLocal\n)\nrevert\nMaxDepositReached\n();\n}\n@>\nuint256\ndeployedAmount\n=\n_deploy\n(\nassets\n);\n// Calculate shares to mint\n@>\nshares\n=\ntotal\n.\ntoBase\n(\ndeployedAmount\n,\nfalse\n);\n// Prevent inflation attack for the first deposit\nif\n(\ntotal\n.\nbase\n==\n0\n&&\nshares\n<\n_MINIMUM_SHARE_BALANCE\n) {\nrevert\nInvalidShareBalance\n();\n}\n// Mint shares to the receiver\n_mint\n(\nreceiver\n,\nshares\n);\n// Emit deposit event\nemit\nDeposit\n(\nmsg\n.\nsender\n,\nreceiver\n,\nassets\n,\nshares\n);\n}\n\nTo withdraw their deployed assets from a BakerFi vault, users must burn a corresponding number of shares to receive a certain amount of assets:\n\nfunction\n_redeemInternal\n(\nuint256\nshares\n,\naddress\nreceiver\n,\naddress\nholder\n,\nbool\nshouldRedeemETH\n)\nprivate\nreturns\n(\nuint256\nretAmount\n) {\nif\n(\nshares\n==\n0\n)\nrevert\nInvalidAmount\n();\nif\n(\nreceiver\n==\naddress\n(\n0\n))\nrevert\nInvalidReceiver\n();\nif\n(\nbalanceOf\n(\nholder\n) <\nshares\n)\nrevert\nNotEnoughBalanceToWithdraw\n();\n// Transfer shares to the contract if sender is not the holder\nif\n(\nmsg\n.\nsender\n!=\nholder\n) {\nif\n(\nallowance\n(\nholder\n,\nmsg\n.\nsender\n) <\nshares\n)\nrevert\nNoAllowance\n();\ntransferFrom\n(\nholder\n,\nmsg\n.\nsender\n,\nshares\n);\n}\n// Calculate the amount to withdraw based on shares\nuint256\nwithdrawAmount\n= (\nshares\n*\ntotalAssets\n()) /\ntotalSupply\n();\nif\n(\nwithdrawAmount\n==\n0\n)\nrevert\nNoAssetsToWithdraw\n();\n@>\nuint256\namount\n=\n_undeploy\n(\nwithdrawAmount\n);\nuint256\nfee\n=\n0\n;\nuint256\nremainingShares\n=\ntotalSupply\n() -\nshares\n;\n// Ensure a minimum number of shares are maintained to prevent ratio distortion\nif\n(\nremainingShares\n<\n_MINIMUM_SHARE_BALANCE\n&&\nremainingShares\n!=\n0\n) {\nrevert\nInvalidShareBalance\n();\n}\n@>\n_burn\n(\nmsg\n.\nsender\n,\nshares\n);\n// Calculate and handle withdrawal fees\nif\n(\ngetWithdrawalFee\n() !=\n0\n&&\ngetFeeReceiver\n() !=\naddress\n(\n0\n)) {\nfee\n=\namount\n.\nmulDivUp\n(\ngetWithdrawalFee\n(),\nPERCENTAGE_PRECISION\n);\nif\n(\nshouldRedeemETH\n&&\n_asset\n() ==\nwETHA\n()) {\nunwrapETH\n(\namount\n);\npayable\n(\nreceiver\n).\nsendValue\n(\namount\n-\nfee\n);\npayable\n(\ngetFeeReceiver\n()).\nsendValue\n(\nfee\n);\n}\nelse\n{\nIERC20Upgradeable\n(\n_asset\n()).\ntransfer\n(\nreceiver\n,\namount\n-\nfee\n);\nIERC20Upgradeable\n(\n_asset\n()).\ntransfer\n(\ngetFeeReceiver\n(),\nfee\n);\n}\n}\nelse\n{\nif\n(\nshouldRedeemETH\n) {\nunwrapETH\n(\namount\n);\npayable\n(\nreceiver\n).\nsendValue\n(\namount\n);\n}\nelse\n{\nIERC20Upgradeable\n(\n_asset\n()).\ntransfer\n(\nreceiver\n,\namount\n);\n}\n}\nemit\nWithdraw\n(\nmsg\n.\nsender\n,\nreceiver\n,\nholder\n,\namount\n-\nfee\n,\nshares\n);\nretAmount\n=\namount\n-\nfee\n;\n}\n\nAs we can see, the return values of\n_deploy()\nand\n_undeploy()\nshould represent the amount of asset. In addition,\n_totalAssets()\nshould also return the amount of asset.\nThe implementation of the above functions within the\nVault\ncontract is as follows:\n\nfunction\n_deploy\n(\nuint256\nassets\n)\ninternal\nvirtual\noverride\nreturns\n(\nuint256\ndeployedAmount\n) {\n// Approve the strategy to spend assets\nIERC20Upgradeable\n(\n_strategyAsset\n).\nsafeApprove\n(\naddress\n(\n_strategy\n),\nassets\n);\n// Deploy assets via the strategy\ndeployedAmount\n=\n_strategy\n.\ndeploy\n(\nassets\n);\n// Calls the deploy function of the strategy\n}\nfunction\n_undeploy\n(\nuint256\nassets\n)\ninternal\nvirtual\noverride\nreturns\n(\nuint256\nretAmount\n) {\nretAmount\n=\n_strategy\n.\nundeploy\n(\nassets\n);\n// Calls the undeploy function of the strategy\n}\nfunction\n_totalAssets\n()\ninternal\nview\nvirtual\noverride\nreturns\n(\nuint256\namount\n) {\namount\n=\n_strategy\n.\ntotalAssets\n();\n// Calls the totalAssets function of the strategy\n}\n\nIt is obvious that the return value should represent the amount of assets when\n_strategy.deploy()\n,\n_strategy.undeploy()\nor\n_strategy.totalAssets()\nis called.\n\nHowever, the functions in\nStrategySupplyERC4626\nmistakenly return the number of shares other than the amount of underlying asset:\n\n/**\n*\n@inheritdoc\nStrategySupplyBase\n*/\nfunction\n_deploy\n(\nuint256\namount\n)\ninternal\noverride\nreturns\n(\nuint256\n) {\nreturn\n_vault\n.\ndeposit\n(\namount\n,\naddress\n(\nthis\n));\n}\n/**\n*\n@inheritdoc\nStrategySupplyBase\n*/\nfunction\n_undeploy\n(\nuint256\namount\n)\ninternal\noverride\nreturns\n(\nuint256\n) {\nreturn\n_vault\n.\nwithdraw\n(\namount\n,\naddress\n(\nthis\n),\naddress\n(\nthis\n));\n}\n/**\n*\n@inheritdoc\nStrategySupplyBase\n*/\nfunction\n_getBalance\n()\ninternal\nview\noverride\nreturns\n(\nuint256\n) {\nreturn\n_vault\n.\nbalanceOf\n(\naddress\n(\nthis\n));\n}\n\nThis issue could lead to a scenario where a portion of user assets are permanently locked within the BakerFi vault.\nCreate\nERC4626Mock\ncontract with below codes:\n\n// SPDX-License-Identifier: MIT\npragma\nsolidity\n^\n0.8\n.\n24\n;\nimport\n{\nERC4626\n}\nfrom\n\"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\"\n;\nimport\n{\nIERC20\n}\nfrom\n\"@openzeppelin/contracts/token/ERC20/IERC20.sol\"\n;\nimport\n{\nERC20\n}\nfrom\n\"@openzeppelin/contracts/token/ERC20/ERC20.sol\"\n;\ncontract\nERC4626Mock\nis\nERC4626\n{\nconstructor\n(\nIERC20\nasset_\n)\nERC4626\n(\nasset_\n)\nERC20\n(\n\"Mock Vault\"\n,\n\"MV\"\n) {\n}\n}\n\nCreate\nStrategySupplyERC4626.ts\nwith below codes and run\nnpm run test\n:\n\nAs we can see that only 5e18 WETH can be withdrawn within 10e18 WETH deployed. The rest 5e18 WETH are permanently locked within the BakerFi vault. The amount of locked asset can be calculated as below:\n\nNote: please see scenario in warden\u2019s\noriginal submission\n.\n\nUpdate\nStrategySupplyERC4626\nto return correct value:\n\nfunction _deploy(uint256 amount) internal override returns (uint256) {\n-       return _vault.deposit(amount, address(this));\n+      _vault.deposit(amount, address(this));\n+      return amount;\n}\n/**\n* @inheritdoc StrategySupplyBase\n*/\nfunction _undeploy(uint256 amount) internal override returns (uint256) {\n-       return _vault.withdraw(amount, address(this), address(this));\n+       _vault.withdraw(amount, address(this), address(this));\n+       return amount;\n}\n/**\n* @inheritdoc StrategySupplyBase\n*/\nfunction _getBalance() internal view override returns (uint256) {\n-       return _vault.balanceOf(address(this));\n+       return _vault.convertToAssets(_vault.balanceOf(address(this)));\n}\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-17\n\nStatus:\nMitigation confirmed. Full details in reports from\nshaflow2\nand\n0xlemon\n.",
        "severity": "high",
        "reason": "No unmatched tool findings remaining"
      },
      {
        "id": "code4rena_bakerfi-invitational_2025_02_expected_001",
        "title": "Anyone can callStrategySupplyBase.harvest, allowing users to avoid paying performance fees on interest",
        "description": "Submitted by\nklau5\n, also found by\n0xlemon\n,\n0xpiken\n, and\nshaflow2\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/strategies/StrategySupplyBase.sol#L90\n\nSince\nStrategySupplyBase.harvest\ncan be called by anyone, users can front-run the\nrebalance\ncall or regularly call harvest to avoid paying protocol fees on interest. This allows users to receive more interest than they should.\n\nWhen there are profits in the Strategy, the administrator calls\nrebalance\nto settle protocol fees(performance fee). This calls\nStrategy.harvest\nto update the total deployed asset amount including interest and returns the amount of newly generated interest. Then\nn%\nof the interest is taken as protocol fees.\n\nfunction\n_harvestAndMintFees\n()\ninternal\n{\nuint256\ncurrentPosition\n=\n_totalAssets\n();\nif\n(\ncurrentPosition\n==\n0\n) {\nreturn\n;\n}\n@>\nint256\nbalanceChange\n=\n_harvest\n();\nif\n(\nbalanceChange\n>\n0\n) {\naddress\nfeeReceiver\n=\ngetFeeReceiver\n();\nuint256\nperformanceFee\n=\ngetPerformanceFee\n();\nif\n(\nfeeReceiver\n!=\naddress\n(\nthis\n) &&\nfeeReceiver\n!=\naddress\n(\n0\n) &&\nperformanceFee\n>\n0\n) {\nuint256\nfeeInEth\n=\nuint256\n(\nbalanceChange\n) *\nperformanceFee\n;\nuint256\nsharesToMint\n=\nfeeInEth\n.\nmulDivUp\n(\ntotalSupply\n(),\ncurrentPosition\n*\nPERCENTAGE_PRECISION\n);\n@>\n_mint\n(\nfeeReceiver\n,\nsharesToMint\n);\n}\n}\n}\nfunction\n_harvest\n()\ninternal\nvirtual\noverride\nreturns\n(\nint256\nbalanceChange\n) {\n@>\nreturn\n_strategy\n.\nharvest\n();\n// Calls the harvest function of the strategy\n}\n\nHowever,\nStrategySupplyBase.harvest\ncan be called by anyone. By front-running the\nrebalance\nrequest or regularly calling this function, users can avoid paying protocol fees on interest. This allows users to receive more interest than they should.\n\n@>\nfunction\nharvest\n()\nexternal\nreturns\n(\nint256\nbalanceChange\n) {\n// Get Balance\nuint256\nnewBalance\n=\ngetBalance\n();\n@>\nbalanceChange\n=\nint256\n(\nnewBalance\n) -\nint256\n(\n_deployedAmount\n);\nif\n(\nbalanceChange\n>\n0\n) {\nemit\nStrategyProfit\n(\nuint256\n(\nbalanceChange\n));\n}\nelse\nif\n(\nbalanceChange\n<\n0\n) {\nemit\nStrategyLoss\n(\nuint256\n(-\nbalanceChange\n));\n}\nif\n(\nbalanceChange\n!=\n0\n) {\nemit\nStrategyAmountUpdate\n(\nnewBalance\n);\n}\n@>\n_deployedAmount\n=\nnewBalance\n;\n}\n\nThis is PoC. It demonstrates that anyone can call\nStrategySupplyBase.harvest\n. This can be run by adding it to the\nStrategySupplyAAVEv3.ts\nfile.\n\nit('PoC - anyone can call harvest', async () => {\nconst { owner, strategySupply, stETH, aave3Pool, otherAccount } = await loadFixture(\ndeployStrategySupplyFixture,\n);\nconst deployAmount = ethers.parseEther('10');\nawait stETH.approve(await strategySupply.getAddress(), deployAmount);\nawait strategySupply.deploy(deployAmount);\n//artificial profit\nawait aave3Pool.mintAtokensArbitrarily(await strategySupply.getAddress(), deployAmount);\nawait expect(strategySupply.connect(otherAccount).harvest())\n.to.emit(strategySupply, 'StrategyProfit')\n.to.emit(strategySupply, 'StrategyAmountUpdate');\n});\n\nAdd the\nonlyOwner\nmodifier to\nStrategySupplyBase.harvest\nto restrict access.\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-15\n\nStatus:\nMitigation confirmed. Full details in reports from\n0xlemon\nand\nshaflow2\n.",
        "severity": "high",
        "reason": "No unmatched tool findings remaining"
      },
      {
        "id": "code4rena_bakerfi-invitational_2025_02_expected_002",
        "title": "_deployedAmountnot updated onStrategySupplyBase.undeploy, preventing performance fees from being collected",
        "description": "Submitted by\nklau5\n, also found by\n0xlemon\n,\n0xpiken\n,\nMrPotatoMagic\n,\npfapostol\n, and\nshaflow2\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/strategies/StrategySupplyBase.sol#L110\n\nStrategySupplyBase.undeploy\ndoes not update\n_deployedAmount\n. As a result, if a withdrawal occurs, even if interest is generated, the protocol cannot collect performance fees through\nrebalance\n.\n\nStrategySupplyBase.undeploy\ndoes not update\n_deployedAmount\n. It should subtract the amount of withdrawn asset tokens.\n\nfunction\nundeploy\n(\nuint256\namount\n)\nexternal\nnonReentrant\nonlyOwner\nreturns\n(\nuint256\nundeployedAmount\n) {\nif\n(\namount\n==\n0\n)\nrevert\nZeroAmount\n();\n// Get Balance\nuint256\nbalance\n=\ngetBalance\n();\nif\n(\namount\n>\nbalance\n)\nrevert\nInsufficientBalance\n();\n// Transfer assets back to caller\nuint256\nwithdrawalValue\n=\n_undeploy\n(\namount\n);\n// Check withdrawal value matches the initial amount\n// Transfer assets to user\nERC20\n(\n_asset\n).\nsafeTransfer\n(\nmsg\n.\nsender\n,\nwithdrawalValue\n);\nbalance\n-=\namount\n;\nemit\nStrategyUndeploy\n(\nmsg\n.\nsender\n,\nwithdrawalValue\n);\nemit\nStrategyAmountUpdate\n(\nbalance\n);\nreturn\namount\n;\n}\n\nAs a result, if a withdrawal occurs, even if interest is generated, the protocol cannot collect performance fees through\nrebalance\n. This is because if the withdrawal amount is greater than the interest earned, the Strategy is considered to have a loss and no fee is taken.\n\n_deployedAmount\n: A\nInterest generated,\ngetBalance\nreturns A + profit\nRequest to withdraw amount B\n_deployedAmount\nis still A\ngetBalance\nreturns A + profit - B\nDuring rebalance,\nbalanceChange\nis (A + profit - B) - A\nThat is, if\nprofit <= B\n, the Strategy is considered to have a loss.\n\nfunction\nharvest\n()\nexternal\nreturns\n(\nint256\nbalanceChange\n) {\n// Get Balance\nuint256\nnewBalance\n=\ngetBalance\n();\n@>\nbalanceChange\n=\nint256\n(\nnewBalance\n) -\nint256\n(\n_deployedAmount\n);\nif\n(\nbalanceChange\n>\n0\n) {\nemit\nStrategyProfit\n(\nuint256\n(\nbalanceChange\n));\n}\nelse\nif\n(\nbalanceChange\n<\n0\n) {\nemit\nStrategyLoss\n(\nuint256\n(-\nbalanceChange\n));\n}\nif\n(\nbalanceChange\n!=\n0\n) {\nemit\nStrategyAmountUpdate\n(\nnewBalance\n);\n}\n_deployedAmount\n=\nnewBalance\n;\n}\n\nThis is PoC.  This shows that when harvested after withdrawal, the Strategy is considered to have a loss. This can be executed by adding it to the\nStrategySupplyAAVEv3.ts\nfile.\n\nit('PoC - harvest returns loss after undeloy', async () => {\nconst { owner, strategySupply, stETH, aave3Pool, otherAccount } = await loadFixture(\ndeployStrategySupplyFixture,\n);\nconst deployAmount = ethers.parseEther('10');\nawait stETH.approve(await strategySupply.getAddress(), deployAmount);\nawait strategySupply.deploy(deployAmount);\n//artificial profit\nconst profit = ethers.parseEther('1');\nawait aave3Pool.mintAtokensArbitrarily(await strategySupply.getAddress(), profit);\n// Undeploy\nconst undeployAmount = ethers.parseEther('2');\nawait strategySupply.undeploy(undeployAmount);\nawait expect(strategySupply.harvest())\n.to.emit(strategySupply, 'StrategyLoss')\n.to.emit(strategySupply, 'StrategyAmountUpdate');\n});\n\nUpdate\n_deployedAmount\nby the withdrawal amount in\nStrategySupplyBase.undeploy\n.\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-12\n\nStatus:\nMitigation confirmed. Full details in reports from\nshaflow2\nand\n0xlemon\n.",
        "severity": "high",
        "reason": "No unmatched tool findings remaining"
      },
      {
        "id": "code4rena_bakerfi-invitational_2025_02_expected_003",
        "title": "There are multiple issues with the decimal conversions between the vault and the strategy",
        "description": "Submitted by\nshaflow2\n, also found by\n0xlemon\n,\n0xpiken\n,\nABAIKUNANBAEV\n,\nklau5\n, and\nshaflow2\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/strategies/StrategyLeverage.sol#L234\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/strategies/StrategyLeverage.sol#L347\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/strategies/StrategyLeverage.sol#L359\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/strategies/StrategyLeverage.sol#L673\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/strategies/StrategyLeverage.sol#L640\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/strategies/StrategySupplyBase.sol#L110\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/strategies/StrategySupplyBase.sol#L69\n\nThe\nStrategyLeverage\ncontract has multiple incorrect decimal handling issues, causing the system to not support tokens with decimals other than 18.\n\nFirst, the vault contract\u2019s share decimal is set to 18, as recommended by the ERC4626 standard. Ideally, the vault\u2019s share decimal should reflect the underlying token\u2019s decimal. Otherwise, conversions through\nconvertToShares\nand\nconvertToAssets\nwould be required.\n\nIn\nStrategyLeverage\n, we can see that all calls to\ntotalAssets()\nare converted to 18 decimals for share calculations.\n\nUnder the above premise, the contract has multiple decimal handling errors, making it incompatible with tokens that use decimals other than 18:\n\nThe\n_deploy\nfunction should return the amount in the system\u2019s 18-decimal format, rather than the token\u2019s native decimal format.\nfunction\n_depositInternal\n(\nuint256\nassets\n,\naddress\nreceiver\n)\nprivate\nreturns\n(\nuint256\nshares\n) {\n...\nuint256\ndeployedAmount\n=\n_deploy\n(\nassets\n);\n// Calculate shares to mint\nshares\n=\ntotal\n.\ntoBase\n(\ndeployedAmount\n,\nfalse\n);\n// Prevent inflation attack for the first deposit\nif\n(\ntotal\n.\nbase\n==\n0\n&&\nshares\n<\n_MINIMUM_SHARE_BALANCE\n) {\nrevert\nInvalidShareBalance\n();\n}\n// Mint shares to the receiver\n_mint\n(\nreceiver\n,\nshares\n);\n// Emit deposit event\nemit\nDeposit\n(\nmsg\n.\nsender\n,\nreceiver\n,\nassets\n,\nshares\n);\n}\nThe\n_deploy\nfunction is used to calculate shares, so it should return the amount in the system\u2019s 18-decimal format. However, the strategy always returns the amount in the token\u2019s native decimal format.\nTo address this, the\n_pendingAmount\nin the\n_supplyBorrow\nfunction should be converted to 18-decimal format.\nIn the\n_redeemInternal\nprocess, the\nwithdrawAmount\npassed to\n_undeploy\nis in 18-decimal format (since\ntotalAssets\nreturns 18-decimal values).\nfunction\n_redeemInternal\n(\nuint256\nshares\n,\naddress\nreceiver\n,\naddress\nholder\n,\nbool\nshouldRedeemETH\n)\nprivate\nreturns\n(\nuint256\nretAmount\n) {\nif\n(\nshares\n==\n0\n)\nrevert\nInvalidAmount\n();\nif\n(\nreceiver\n==\naddress\n(\n0\n))\nrevert\nInvalidReceiver\n();\nif\n(\nbalanceOf\n(\nholder\n) <\nshares\n)\nrevert\nNotEnoughBalanceToWithdraw\n();\n// Transfer shares to the contract if sender is not the holder\nif\n(\nmsg\n.\nsender\n!=\nholder\n) {\nif\n(\nallowance\n(\nholder\n,\nmsg\n.\nsender\n) <\nshares\n)\nrevert\nNoAllowance\n();\ntransferFrom\n(\nholder\n,\nmsg\n.\nsender\n,\nshares\n);\n}\n// Calculate the amount to withdraw based on shares\nuint256\nwithdrawAmount\n= (\nshares\n*\ntotalAssets\n()) /\ntotalSupply\n();\nif\n(\nwithdrawAmount\n==\n0\n)\nrevert\nNoAssetsToWithdraw\n();\n\n@>        uint256 amount = _undeploy(withdrawAmount);\n\u2026\n\nTherefore, in the `undeploy` process, `deltaCollateralAmount` is in 18-decimal format. It is directly packed into `data` and passed to `_repayAndWithdraw` during the callback.\nAs a result, the `_withdraw` functions in `StrategyLeverageAAVEv3` and `StrategyLeverageMorphoBlue` should convert the input `amount` from 18-decimal format to the token's actual decimal format. Otherwise, the wrong amount will be withdrawn.\n3. In the `_undeploy` process, `deltaDebt` and fees should be converted from 18-decimal format to the `debtToken`'s actual decimal format.\n4. The `_convertToCollateral` and `_convertToDebt` functions expect the `amount` parameter to be in 18-decimal format, as required for calculations by `_toDebt` and `_toCollateral` using the oracle. However, before proceeding with the swap, the amount needs to be converted to the respective token's actual decimal format.\nAdditionally, `_convertToCollateral` receives the token's original decimal `amount` during the deploy process, leading to incorrect calculations by the oracle.\n```solidity\n/**\n* @dev Internal function to convert the specified amount from Debt Token to the underlying collateral asset cbETH, wstETH, rETH.\n*\n* This function is virtual and intended to be overridden in derived contracts for customized implementation.\n*\n* @param amount The amount to convert from debtToken.\n* @return uint256 The converted amount in the underlying collateral.\n*/\nfunction _convertToCollateral(uint256 amount) internal virtual returns (uint256) {\nuint256 amountOutMinimum = 0;\nif (getMaxSlippage() > 0) {\nuint256 wsthETHAmount = _toCollateral(\nIOracle.PriceOptions({maxAge: getPriceMaxAge(), maxConf: getPriceMaxConf()}),\namount,\nfalse\n);\namountOutMinimum = (wsthETHAmount * (PERCENTAGE_PRECISION - getMaxSlippage())) / PERCENTAGE_PRECISION;\n}\n// 1. Swap Debt Token -> Collateral Token\n(, uint256 amountOut) = swap(\nISwapHandler.SwapParams(\n_debtToken, // Asset In\n_collateralToken, // Asset Out\nISwapHandler.SwapType.EXACT_INPUT, // Swap Mode\namount, // Amount In\namountOutMinimum, // Amount Out\nbytes(\"\") // User Payload\n)\n);\nreturn amountOut;\n}\n/**\n* @dev Internal function to convert the specified amount to Debt Token from the underlying collateral.\n*\n* This function is virtual and intended to be overridden in derived contracts for customized implementation.\n*\n* @param amount The amount to convert to Debt Token.\n* @return uint256 The converted amount in Debt Token.\n*/\nfunction _convertToDebt(uint256 amount) internal virtual returns (uint256) {\nuint256 amountOutMinimum = 0;\nif (getMaxSlippage() > 0) {\nuint256 ethAmount = _toDebt(\nIOracle.PriceOptions({maxAge: getPriceMaxAge(), maxConf: getPriceMaxConf()}),\namount,\nfalse\n);\namountOutMinimum = (ethAmount * (PERCENTAGE_PRECISION - getMaxSlippage())) / PERCENTAGE_PRECISION;\n}\n// 1.Swap Colalteral -> Debt Token\n(, uint256 amountOut) = swap(\nISwapHandler.SwapParams(\n_collateralToken, // Asset In\n_debtToken, // Asset Out\nISwapHandler.SwapType.EXACT_INPUT, // Swap Mode\namount, // Amount In\namountOutMinimum, // Amount Out\nbytes(\"\") // User Payload\n)\n);\nreturn amountOut;\n}\n\nThe\n_convertToCollateral\nand\n_convertToDebt\nfunctions default to returning the\namount\nin the token\u2019s actual decimal format. However, certain parts of the code assume they return the amount in 18-decimal format, leading to potential miscalculations.\nThe\n_adjustDebt\nfunction should convert the flash loan amount from 18-decimal format to the token\u2019s original decimal format.\nThe\n_payDebt\nfunction will receive an amount in 18-decimal format, but when performing the swap, the amount is not converted to the token\u2019s actual decimal format. This can lead to incorrect calculations during the swap process.\n\nIt is recommended to align the vault\u2019s decimals with the underlying token\u2019s decimals instead of using 18 decimals. This alignment can significantly reduce the complexity of decimal conversions throughout the system.\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-24\n\nStatus:\nMitigation confirmed. Full details in reports from\n0xlemon\nand\nshaflow2\n.",
        "severity": "high",
        "reason": "No unmatched tool findings remaining"
      },
      {
        "id": "code4rena_bakerfi-invitational_2025_02_expected_004",
        "title": "The implementation ofpullTokensWithPermitposes a risk, allowing malicious actors to steal tokens",
        "description": "Submitted by\nshaflow2\n, also found by\n0xlemon\nand\nMrPotatoMagic\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/3873b82ae8b321473f3afaf08727e97be0635be9/contracts/core/hooks/UsePermitTransfers.sol#L31\n\nIn batch operations interacting with the router, users are allowed to input tokens into the router using the\npermit\nmethod. This approach may be vulnerable to frontrunning attacks, allowing malicious actors to steal the user\u2019s tokens.\n\nfunction\npullTokensWithPermit\n(\nIERC20Permit\ntoken\n,\nuint256\namount\n,\naddress\nowner\n,\nuint256\ndeadline\n,\nuint8\nv\n,\nbytes32\nr\n,\nbytes32\ns\n)\ninternal\nvirtual\n{\n// Permit the VaultRouter to spend tokens on behalf of the owner\nIERC20Permit\n(\ntoken\n).\npermit\n(\nowner\n,\naddress\n(\nthis\n),\namount\n,\ndeadline\n,\nv\n,\nr\n,\ns\n);\n// Transfer the tokens from the owner to this contract\nIERC20\n(\naddress\n(\ntoken\n)).\nsafeTransferFrom\n(\nowner\n,\naddress\n(\nthis\n),\namount\n);\n}\n\nUsers can deposit tokens into the router via the\npullTokensWithPermit\nfunction. However, the router contract does not validate the caller\u2019s information, making it possible for a malicious actor to frontrun the user and exploit their permit signature to steal tokens.\n\nConsider the following scenario:\n\nThe user interacts with the router contract:\nStep 1: Calls\npullTokensWithPermit\nto transfer 1000 tokens to the router.\nStep 2: Deposits the tokens into a designated vault.\nA malicious actor observes the user\u2019s transaction in the mempool and constructs a malicious transaction to steal the user\u2019s tokens:\nStep 1: The attacker calls\npullTokensWithPermit\nusing the user\u2019s permit signature, causing the user to transfer 1000 tokens to the router.\nStep 2: The attacker immediately calls sweepTokens to transfer the tokens to their own account.\nWhen the user\u2019s original transaction is executed:\nThe permit signature has already been used, causing the user\u2019s transaction to fail.\nAs a result, the user loses 1000 tokens.\n\nAdditionally, an attacker could frontrun the\npermit\nfunction without using the\nrouter\nand then call\npushTokenFrom\ndirectly to steal tokens.\n\nThe current\nrouter\nis not suitable for integrating\npermit\nto handle token input.\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-23\n\nStatus:\nMitigation confirmed. Full details in reports from\n0xlemon\nand\nshaflow2\n.",
        "severity": "high",
        "reason": "No unmatched tool findings remaining"
      },
      {
        "id": "code4rena_bakerfi-invitational_2025_02_expected_005",
        "title": "Malicious actors can exploit user-approved allowances onVaultRouterto drain their ERC20 tokens",
        "description": "Submitted by\n0xpiken\n, also found by\n0xlemon\n,\nMrPotatoMagic\n, and\nshaflow2\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/VaultRouter.sol#L186-L202\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/VaultRouter.sol#L234-L252\n\nOnce a user approves\nVaultRouter\nto spend their ERC20 tokens, anyone could call\nVaultRouter#execute()\nto drain the user\u2019s ERC20 assets.\n\nThe\nVaultRouter#execute()\nfunction allows users to perform multiple commands within a single transaction. One such use case involves depositing ERC20 tokens into\nVaultRouter\nusing the\nPULL_TOKEN\ncommand. Subsequently, these tokens can be further processed within the same transaction through other commands, such as\nV3_UNISWAP_SWAP\nfor token swaps or\nERC4626_VAULT_DEPOSIT\nfor depositing into an ERC4626 vault.\nBefore depositing ERC20 tokens into\nVaultRouter\nusing the\nPULL_TOKEN\ncommand, the user must approve\nVaultRouter\nto spend their ERC20 token in advance.  However, a malicious actor can exploit this approval to drain the user\u2019s ERC20 token through\nVaultRouter\nwith\nPULL_TOKEN_FROM\nor\nPUSH_TOKEN_FROM\ncommands:\n\nA malicious actor can call\nPULL_TOKEN_FROM\nto transfer ERC20 token from the user into\nVaultRouter\n, then use\nPUSH_TOKEN\ncommand to transfer drained token from\nVaultRouter\nto specified address.\nA malicious actor can call\nPUSH_TOKEN_FROM\ncommand transfer ERC20 token from the user to any address directly.\n\nThe root cause is that either\nPULL_TOKEN_FROM\nor\nPUSH_TOKEN_FROM\ncommand allows anyone to transfer a user\u2019s ERC20 token as long as\nVaultRouter\nis approved to spend their assets:\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/hooks/UseTokenActions.sol\n\nfunction\npullTokenFrom\n(\nIERC20\ntoken\n,\naddress\nfrom\n,\nuint256\namount\n)\ninternal\nvirtual\n{\n// Check if the token address is valid\nif\n(\naddress\n(\ntoken\n) ==\naddress\n(\n0\n))\nrevert\nInvalidToken\n();\nif\n(\ntoken\n.\nallowance\n(\nfrom\n,\naddress\n(\nthis\n)) <\namount\n)\nrevert\nNotEnoughAllowance\n();\n// Use SafeERC20 to transfer tokens from the specified address to this contract\n@>\nIERC20\n(\ntoken\n).\nsafeTransferFrom\n(\nfrom\n,\naddress\n(\nthis\n),\namount\n);\n}\nfunction\npushTokenFrom\n(\nIERC20\ntoken\n,\naddress\nfrom\n,\naddress\nto\n,\nuint256\namount\n)\ninternal\nvirtual\n{\n// Check if the token address is valid\nif\n(\naddress\n(\ntoken\n) ==\naddress\n(\n0\n))\nrevert\nInvalidToken\n();\n// Check if the recipient address is valid\nif\n(\naddress\n(\nto\n) ==\naddress\n(\n0\n))\nrevert\nInvalidRecipient\n();\nif\n(\ntoken\n.\nallowance\n(\nfrom\n,\naddress\n(\nthis\n)) <\namount\n)\nrevert\nNotEnoughAllowance\n();\n// Use SafeERC20 to transfer tokens from the specified address to another specified address\n@>\nIERC20\n(\ntoken\n).\nsafeTransferFrom\n(\nfrom\n,\nto\n,\namount\n);\n}\n\nCopy below codes to\nVaultRouter.ts\nand run\nnpm run test\n:\n\nit\n.\nonly\n(\n'Drain all WETH from owner'\n,\nasync\nfunction\n() {\nconst\n{\nvaultRouter\n,\nweth\n,\nowner\n,\notherAccount\n} =\nawait\ndeployFunction\n();\n//@audit-info owner has 10000e18 WETH\nexpect\n(\nawait\nweth\n.\nbalanceOf\n(\nowner\n.\naddress\n)).\nto\n.\nequal\n(\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n));\n//@audit-info owner approves vaultRouter to spend their WETH\nawait\nweth\n.\napprove\n(\nawait\nvaultRouter\n.\ngetAddress\n(),\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n));\nlet\niface\n=\nnew\nethers\n.\nInterface\n(\nVaultRouterABI\n);\nconst\ncommands\n= [\n[\nVAULT_ROUTER_COMMAND_ACTIONS\n.\nPUSH_TOKEN_FROM\n,\n'0x'\n+\niface\n.\nencodeFunctionData\n(\n'pushTokenFrom'\n, [\nawait\nweth\n.\ngetAddress\n(),\nowner\n.\naddress\n,\notherAccount\n.\naddress\n,\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n)])\n.\nslice\n(\n10\n),\n],\n];\n//@audit-info otherAccount drains owner's WETH\nawait\nvaultRouter\n.\nconnect\n(\notherAccount\n).\nexecute\n(\ncommands\n);\nexpect\n(\nawait\nweth\n.\nbalanceOf\n(\nowner\n.\naddress\n)).\nto\n.\nequal\n(\n0\n);\nexpect\n(\nawait\nweth\n.\nbalanceOf\n(\notherAccount\n.\naddress\n)).\nto\n.\nequal\n(\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n));\n});\n\nAs we can see, owner\u2019s all WETH was drained.\n\nTo protect users from potential exploitation, the\nPULL_TOKEN_FROM\nand\nPUSH_TOKEN_FROM\ncommands should be executed only when\nmsg.sender\nis\nfrom\n.\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-20\n\nStatus:\nMitigation confirmed. Full details in reports from\n0xlemon\nand\nshaflow2\n.",
        "severity": "high",
        "reason": "No unmatched tool findings remaining"
      },
      {
        "id": "code4rena_bakerfi-invitational_2025_02_expected_006",
        "title": "Malicious actors can exploit user-approved allowances onVaultRouterto drain their ERC4626 tokens",
        "description": "Submitted by\n0xpiken\n, also found by\nMrPotatoMagic\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/VaultRouter.sol#L120\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/VaultRouter.sol#L122\n\nOnce a user approves\nVaultRouter\nto spend their ERC4626 shares, anyone could call\nVaultRouter#execute()\nto drain the user\u2019s ERC4626 shares.\n\nThe\nVaultRouter#execute()\nfunction allows users to perform multiple commands within a single transaction. A user can redeem their ERC4626 shares for underlying assets through\nVaultRouter\nusing the\nERC4626_VAULT_REDEEM\ncommand. Subsequently, the redeemed underlying assets can be further processed within the same transaction through other commands, such as\nV3_UNISWAP_SWAP\nfor token swaps or\nPUSH_TOKEN\nfor token transferrings.\nRedeem ERC4626 shares for underlying assets:\n\nfunction\n_handleVaultRedeem\n(\nbytes\ncalldata\ndata\n,\nuint256\n[]\nmemory\ncallStack\n,\nuint32\ninputMapping\n,\nuint32\noutputMapping\n)\nprivate\nreturns\n(\nbytes\nmemory\n) {\nIERC4626\nvault\n;\nuint256\nshares\n;\naddress\nreceiver\n;\naddress\nowner\n;\nassembly\n{\nvault :=\ncalldataload\n(\ndata\n.\noffset\n)\nshares :=\ncalldataload\n(\nadd\n(\ndata\n.\noffset\n,\n0x20\n))\nreceiver :=\ncalldataload\n(\nadd\n(\ndata\n.\noffset\n,\n0x40\n))\nowner :=\ncalldataload\n(\nadd\n(\ndata\n.\noffset\n,\n0x60\n))\n}\nshares\n=\nCommands\n.\npullInputParam\n(\ncallStack\n,\nshares\n,\ninputMapping\n,\n1\n);\nuint256\nassets\n=\nredeemVault\n(\nvault\n,\nshares\n,\nreceiver\n,\nowner\n);\nCommands\n.\npushOutputParam\n(\ncallStack\n,\nassets\n,\noutputMapping\n,\n1\n);\nreturn\nabi\n.\nencodePacked\n(\nassets\n);\n}\n\nWithdraw underlying assets by burning shares:\n\nfunction\n_handleVaultWithdraw\n(\nbytes\ncalldata\ndata\n,\nuint256\n[]\nmemory\ncallStack\n,\nuint32\ninputMapping\n,\nuint32\noutputMapping\n)\nprivate\nreturns\n(\nbytes\nmemory\n) {\nIERC4626\nvault\n;\nuint256\nassets\n;\naddress\nreceiver\n;\naddress\nowner\n;\nassembly\n{\nvault :=\ncalldataload\n(\ndata\n.\noffset\n)\nassets :=\ncalldataload\n(\nadd\n(\ndata\n.\noffset\n,\n0x20\n))\nreceiver :=\ncalldataload\n(\nadd\n(\ndata\n.\noffset\n,\n0x40\n))\nowner :=\ncalldataload\n(\nadd\n(\ndata\n.\noffset\n,\n0x60\n))\n}\nassets\n=\nCommands\n.\npullInputParam\n(\ncallStack\n,\nassets\n,\ninputMapping\n,\n1\n);\nuint256\nshares\n=\nwithdrawVault\n(\nvault\n,\nassets\n,\nreceiver\n,\nowner\n);\nCommands\n.\npushOutputParam\n(\ncallStack\n,\nshares\n,\noutputMapping\n,\n1\n);\nreturn\nabi\n.\nencodePacked\n(\nshares\n);\n}\n\nTo allow\nVaultRouter\nto redeem ERC4626 shares on behalf of a user, the user must approve\nVaultRouter\nto spend their shares in advance.  However, the caller can be anyone when handling ERC4626 shares redeeming / underlying asset withdrawing, a malicious actor can exploit this approval to drain the user\u2019s ERC4626 shares.\n\nCopy below codes to\nVaultRouter.ts\nand run\nnpm run test\n:\n\nit\n.\nonly\n(\n'Drain ERC4626 shares'\n,\nasync\nfunction\n() {\nconst\n{\nvaultRouter\n,\nweth\n,\nvault\n,\nowner\n,\notherAccount\n} =\nawait\ndeployFunction\n();\nawait\nweth\n.\napprove\n(\nawait\nvault\n.\ngetAddress\n(),\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n));\n//@audit-info deposit 10000e18 WETH into vault for 10000e18 shares\nawait\nvault\n.\ndeposit\n(\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n),\nowner\n.\naddress\n);\nexpect\n(\nawait\nvault\n.\nbalanceOf\n(\nowner\n.\naddress\n)).\nto\n.\nequal\n(\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n));\n// Approve the VaultRouter to spend vault shares from owner\nawait\nvault\n.\napprove\n(\nawait\nvaultRouter\n.\ngetAddress\n(),\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n));\nlet\niface\n=\nnew\nethers\n.\nInterface\n(\nVaultRouterABI\n);\nconst\ncommands\n= [\n[\nVAULT_ROUTER_COMMAND_ACTIONS\n.\nERC4626_VAULT_REDEEM\n,\n'0x'\n+\niface\n.\nencodeFunctionData\n(\n'redeemVault'\n, [\nawait\nvault\n.\ngetAddress\n(),\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n),\nawait\notherAccount\n.\ngetAddress\n(),\nowner\n.\naddress\n,\n])\n.\nslice\n(\n10\n),\n],\n];\n//@audit-info otherAccount crafts commands to drain owner's vault shares\nawait\nvaultRouter\n.\nconnect\n(\notherAccount\n).\nexecute\n(\ncommands\n);\n//@audit-info all shares are drained for 10000e18 WETH and transferred to the malicious user\nexpect\n(\nawait\nvault\n.\nbalanceOf\n(\nowner\n.\naddress\n)).\nto\n.\nequal\n(\n0\n);\nexpect\n(\nawait\nweth\n.\nbalanceOf\n(\notherAccount\n.\naddress\n)).\nto\n.\nequal\n(\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n));\n});\n\nAs we can see, all owner\u2019s vault shares were drained.\n\nBoth\nERC4626_VAULT_REDEEM\nand\nERC4626_VAULT_WITHDRAW\ncommands should only handle the caller\u2019s ERC4626 shares:\n\nfunction _handleVaultRedeem(\nbytes calldata data,\nuint256[] memory callStack,\nuint32 inputMapping,\nuint32 outputMapping\n) private returns (bytes memory) {\nIERC4626 vault;\nuint256 shares;\naddress receiver;\naddress owner;\nassembly {\nvault := calldataload(data.offset)\nshares := calldataload(add(data.offset, 0x20))\nreceiver := calldataload(add(data.offset, 0x40))\n-           owner := calldataload(add(data.offset, 0x60))\n}\n+       owner = msg.sender;\nshares = Commands.pullInputParam(callStack, shares, inputMapping, 1);\nuint256 assets = redeemVault(vault, shares, receiver, owner);\nCommands.pushOutputParam(callStack, assets, outputMapping, 1);\nreturn abi.encodePacked(assets);\n}\nfunction _handleVaultWithdraw(\nbytes calldata data,\nuint256[] memory callStack,\nuint32 inputMapping,\nuint32 outputMapping\n) private returns (bytes memory) {\nIERC4626 vault;\nuint256 assets;\naddress receiver;\naddress owner;\nassembly {\nvault := calldataload(data.offset)\nassets := calldataload(add(data.offset, 0x20))\nreceiver := calldataload(add(data.offset, 0x40))\n-           owner := calldataload(add(data.offset, 0x60))\n}\n+       owner = msg.sender;\nassets = Commands.pullInputParam(callStack, assets, inputMapping, 1);\nuint256 shares = withdrawVault(vault, assets, receiver, owner);\nCommands.pushOutputParam(callStack, shares, outputMapping, 1);\nreturn abi.encodePacked(shares);\n}\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-19\n\nStatus:\nMitigation confirmed. Full details in reports from\n0xlemon\nand\nshaflow2\n.",
        "severity": "high",
        "reason": "No unmatched tool findings remaining"
      }
    ],
    "extra_findings": [],
    "undecided_findings": []
  }
}